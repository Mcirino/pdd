{
  "path": "process/init/app/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/init/app\n# {\"style\":\"cmd_extractor\",\"cmd\":\"\\n        deepdive db init\\n\\n        cd \\\"$DEEPDIVE_APP\\\"\\n        # run legacy schema.sql\\n        if [[ -r schema.sql ]]; then\\n            deepdive db prompt <schema.sql\\n        fi\\n        # run legacy init script\\n        if [[ -x input/init.sh ]]; then\\n            input/init.sh\\n        fi\\n        \",\"name\":\"process/init/app\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/init/app'\n\n        deepdive db init\n\n        cd \"$DEEPDIVE_APP\"\n        # run legacy schema.sql\n        if [[ -r schema.sql ]]; then\n            deepdive db prompt <schema.sql\n        fi\n        # run legacy init script\n        if [[ -x input/init.sh ]]; then\n            input/init.sh\n        fi\n        \n\n\n"
}
{
  "path": "process/init/relation/sentences_original/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/init/relation/sentences_original\n# {\"style\":\"cmd_extractor\",\"cmd\":\"deepdive create table 'sentences_original' && deepdive load 'sentences_original'\",\"dependencies_\":[\"process/init/app\"],\"output_relation\":\"sentences_original\",\"output_\":\"data/sentences_original\",\"name\":\"process/init/relation/sentences_original\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/init/relation/sentences_original'\ndeepdive create table 'sentences_original' && deepdive load 'sentences_original'\n\n\n"
}
{
  "path": "process/ext_all_entity_candidate/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_all_entity_candidate\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"all_entity_candidate\\\"\\n\\tdeepdive sql 'INSERT INTO all_entity_candidate SELECT R0.docid AS \\\"entity_formation_candidate.R0.docid\\\", '\\\\''FORMATION'\\\\'' AS column_1, R0.eid AS \\\"entity_formation_candidate.R0.eid\\\", R0.entity AS \\\"entity_formation_candidate.R0.entity\\\", R0.prov AS \\\"entity_formation_candidate.R0.prov\\\"\\nFROM entity_formation_candidate R0\\n        \\nUNION ALL\\nSELECT R0.docid AS \\\"entity_temporal_candidate.R0.docid\\\", '\\\\''INTERVAL'\\\\'' AS column_1, R0.eid AS \\\"entity_temporal_candidate.R0.eid\\\", R0.entity AS \\\"entity_temporal_candidate.R0.entity\\\", R0.prov AS \\\"entity_temporal_candidate.R0.prov\\\"\\nFROM entity_temporal_candidate R0\\n        \\nUNION ALL\\nSELECT R0.docid AS \\\"entity_taxon_candidate.R0.docid\\\", '\\\\''TAXON-'\\\\'' || R0.type AS column_1, R0.eid AS \\\"entity_taxon_candidate.R0.eid\\\", R0.entity AS \\\"entity_taxon_candidate.R0.entity\\\", R0.prov AS \\\"entity_taxon_candidate.R0.prov\\\"\\nFROM entity_taxon_candidate R0\\n        \\nUNION ALL\\nSELECT R0.docid AS \\\"entity_location_candidate.R0.docid\\\", '\\\\''LOCATION'\\\\'' AS column_1, R0.eid AS \\\"entity_location_candidate.R0.eid\\\", R0.entity AS \\\"entity_location_candidate.R0.entity\\\", R0.prov AS \\\"entity_location_candidate.R0.prov\\\"\\nFROM entity_location_candidate R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_formation_candidate\",\"ext_entity_temporal_candidate_by_ext_entity_temporal_local\",\"ext_entity_taxon_candidate\",\"ext_entity_location_candidate_by_ext_entity_location_global\"],\"input_relations\":[\"entity_formation_candidate\",\"entity_temporal_candidate\",\"entity_taxon_candidate\",\"entity_location_candidate\"],\"output_relation\":\"all_entity_candidate\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_formation_candidate\",\"process/ext_entity_temporal_candidate_by_ext_entity_temporal_local\",\"process/ext_entity_taxon_candidate\",\"process/ext_entity_location_candidate_by_ext_entity_location_global\"],\"input_\":[\"data/entity_formation_candidate\",\"data/entity_temporal_candidate\",\"data/entity_taxon_candidate\",\"data/entity_location_candidate\"],\"output_\":\"data/all_entity_candidate\",\"name\":\"process/ext_all_entity_candidate\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_all_entity_candidate'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"all_entity_candidate\"\n\tdeepdive sql 'INSERT INTO all_entity_candidate SELECT R0.docid AS \"entity_formation_candidate.R0.docid\", '\\''FORMATION'\\'' AS column_1, R0.eid AS \"entity_formation_candidate.R0.eid\", R0.entity AS \"entity_formation_candidate.R0.entity\", R0.prov AS \"entity_formation_candidate.R0.prov\"\nFROM entity_formation_candidate R0\n        \nUNION ALL\nSELECT R0.docid AS \"entity_temporal_candidate.R0.docid\", '\\''INTERVAL'\\'' AS column_1, R0.eid AS \"entity_temporal_candidate.R0.eid\", R0.entity AS \"entity_temporal_candidate.R0.entity\", R0.prov AS \"entity_temporal_candidate.R0.prov\"\nFROM entity_temporal_candidate R0\n        \nUNION ALL\nSELECT R0.docid AS \"entity_taxon_candidate.R0.docid\", '\\''TAXON-'\\'' || R0.type AS column_1, R0.eid AS \"entity_taxon_candidate.R0.eid\", R0.entity AS \"entity_taxon_candidate.R0.entity\", R0.prov AS \"entity_taxon_candidate.R0.prov\"\nFROM entity_taxon_candidate R0\n        \nUNION ALL\nSELECT R0.docid AS \"entity_location_candidate.R0.docid\", '\\''LOCATION'\\'' AS column_1, R0.eid AS \"entity_location_candidate.R0.eid\", R0.entity AS \"entity_location_candidate.R0.entity\", R0.prov AS \"entity_location_candidate.R0.prov\"\nFROM entity_location_candidate R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_all_entity_per_doc/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_all_entity_per_doc\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"all_entity_per_doc\\\"\\n\\tdeepdive sql 'INSERT INTO all_entity_per_doc SELECT R0.docid AS \\\"all_entity_candidate.R0.docid\\\", ARRAY_AGG(R0.eid) AS column_1, ARRAY_AGG(R0.entity) AS column_2, ARRAY_AGG(R0.type) AS column_3, ARRAY_AGG(R0.prov) AS column_4\\nFROM all_entity_candidate R0\\n        \\n        GROUP BY R0.docid'\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_all_entity_candidate\"],\"input_relations\":[\"all_entity_candidate\"],\"output_relation\":\"all_entity_per_doc\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_all_entity_candidate\"],\"input_\":[\"data/all_entity_candidate\"],\"output_\":\"data/all_entity_per_doc\",\"name\":\"process/ext_all_entity_per_doc\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_all_entity_per_doc'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"all_entity_per_doc\"\n\tdeepdive sql 'INSERT INTO all_entity_per_doc SELECT R0.docid AS \"all_entity_candidate.R0.docid\", ARRAY_AGG(R0.eid) AS column_1, ARRAY_AGG(R0.entity) AS column_2, ARRAY_AGG(R0.type) AS column_3, ARRAY_AGG(R0.prov) AS column_4\nFROM all_entity_candidate R0\n        \n        GROUP BY R0.docid'\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_document_with_all_entities/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_document_with_all_entities\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"document_with_all_entities\\\"\\n\\tdeepdive sql 'INSERT INTO document_with_all_entities SELECT R0.docid AS \\\"all_entity_per_doc.R0.docid\\\", array_to_string(R0.entity, '\\\\''@@@@@'\\\\'') AS column_1, array_to_string(R0.type, '\\\\''@@@@@'\\\\'') AS column_2, array_to_string(R0.eid, '\\\\''@@@@@'\\\\'') AS column_3, array_to_string(R0.prov, '\\\\''@@@@@'\\\\'') AS column_4, R1.sentids AS \\\"documents_serialized.R1.sentids\\\", R1.wordidxs AS \\\"documents_serialized.R1.wordidxs\\\", R1.words AS \\\"documents_serialized.R1.words\\\", R1.poses AS \\\"documents_serialized.R1.poses\\\", R1.ners AS \\\"documents_serialized.R1.ners\\\", R1.lemmas AS \\\"documents_serialized.R1.lemmas\\\", R1.dep_paths AS \\\"documents_serialized.R1.dep_paths\\\", R1.dep_parents AS \\\"documents_serialized.R1.dep_parents\\\", R1.font AS \\\"documents_serialized.R1.font\\\", R1.layout AS \\\"documents_serialized.R1.layout\\\"\\nFROM all_entity_per_doc R0, documents_serialized R1\\n        WHERE R1.docid = R0.docid '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_all_entity_per_doc\",\"ext_documents_serialized\"],\"input_relations\":[\"all_entity_per_doc\",\"documents_serialized\"],\"output_relation\":\"document_with_all_entities\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_all_entity_per_doc\",\"process/ext_documents_serialized\"],\"input_\":[\"data/all_entity_per_doc\",\"data/documents_serialized\"],\"output_\":\"data/document_with_all_entities\",\"name\":\"process/ext_document_with_all_entities\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_document_with_all_entities'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"document_with_all_entities\"\n\tdeepdive sql 'INSERT INTO document_with_all_entities SELECT R0.docid AS \"all_entity_per_doc.R0.docid\", array_to_string(R0.entity, '\\''@@@@@'\\'') AS column_1, array_to_string(R0.type, '\\''@@@@@'\\'') AS column_2, array_to_string(R0.eid, '\\''@@@@@'\\'') AS column_3, array_to_string(R0.prov, '\\''@@@@@'\\'') AS column_4, R1.sentids AS \"documents_serialized.R1.sentids\", R1.wordidxs AS \"documents_serialized.R1.wordidxs\", R1.words AS \"documents_serialized.R1.words\", R1.poses AS \"documents_serialized.R1.poses\", R1.ners AS \"documents_serialized.R1.ners\", R1.lemmas AS \"documents_serialized.R1.lemmas\", R1.dep_paths AS \"documents_serialized.R1.dep_paths\", R1.dep_parents AS \"documents_serialized.R1.dep_parents\", R1.font AS \"documents_serialized.R1.font\", R1.layout AS \"documents_serialized.R1.layout\"\nFROM all_entity_per_doc R0, documents_serialized R1\n        WHERE R1.docid = R0.docid '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_document_with_formation_entities/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_document_with_formation_entities\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"document_with_formation_entities\\\"\\n\\tdeepdive sql 'INSERT INTO document_with_formation_entities SELECT R0.docid AS \\\"formation_per_doc.R0.docid\\\", array_to_string(R0.entity, '\\\\''@@@@@'\\\\'') AS column_1, array_to_string(R0.type, '\\\\''@@@@@'\\\\'') AS column_2, R1.sentids AS \\\"documents_serialized.R1.sentids\\\", R1.wordidxs AS \\\"documents_serialized.R1.wordidxs\\\", R1.words AS \\\"documents_serialized.R1.words\\\", R1.poses AS \\\"documents_serialized.R1.poses\\\", R1.ners AS \\\"documents_serialized.R1.ners\\\", R1.lemmas AS \\\"documents_serialized.R1.lemmas\\\", R1.dep_paths AS \\\"documents_serialized.R1.dep_paths\\\", R1.dep_parents AS \\\"documents_serialized.R1.dep_parents\\\", R1.font AS \\\"documents_serialized.R1.font\\\", R1.layout AS \\\"documents_serialized.R1.layout\\\"\\nFROM formation_per_doc R0, documents_serialized R1\\n        WHERE R1.docid = R0.docid '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_formation_per_doc\",\"ext_documents_serialized\"],\"input_relations\":[\"formation_per_doc\",\"documents_serialized\"],\"output_relation\":\"document_with_formation_entities\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_formation_per_doc\",\"process/ext_documents_serialized\"],\"input_\":[\"data/formation_per_doc\",\"data/documents_serialized\"],\"output_\":\"data/document_with_formation_entities\",\"name\":\"process/ext_document_with_formation_entities\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_document_with_formation_entities'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"document_with_formation_entities\"\n\tdeepdive sql 'INSERT INTO document_with_formation_entities SELECT R0.docid AS \"formation_per_doc.R0.docid\", array_to_string(R0.entity, '\\''@@@@@'\\'') AS column_1, array_to_string(R0.type, '\\''@@@@@'\\'') AS column_2, R1.sentids AS \"documents_serialized.R1.sentids\", R1.wordidxs AS \"documents_serialized.R1.wordidxs\", R1.words AS \"documents_serialized.R1.words\", R1.poses AS \"documents_serialized.R1.poses\", R1.ners AS \"documents_serialized.R1.ners\", R1.lemmas AS \"documents_serialized.R1.lemmas\", R1.dep_paths AS \"documents_serialized.R1.dep_paths\", R1.dep_parents AS \"documents_serialized.R1.dep_parents\", R1.font AS \"documents_serialized.R1.font\", R1.layout AS \"documents_serialized.R1.layout\"\nFROM formation_per_doc R0, documents_serialized R1\n        WHERE R1.docid = R0.docid '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_document_with_taxon_entities/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_document_with_taxon_entities\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"document_with_taxon_entities\\\"\\n\\tdeepdive sql 'INSERT INTO document_with_taxon_entities SELECT R0.docid AS \\\"taxon_per_doc.R0.docid\\\", array_to_string(R0.entity, '\\\\''@@@@@'\\\\'') AS column_1, array_to_string(R0.type, '\\\\''@@@@@'\\\\'') AS column_2, R1.sentids AS \\\"documents_serialized.R1.sentids\\\", R1.wordidxs AS \\\"documents_serialized.R1.wordidxs\\\", R1.words AS \\\"documents_serialized.R1.words\\\", R1.poses AS \\\"documents_serialized.R1.poses\\\", R1.ners AS \\\"documents_serialized.R1.ners\\\", R1.lemmas AS \\\"documents_serialized.R1.lemmas\\\", R1.dep_paths AS \\\"documents_serialized.R1.dep_paths\\\", R1.dep_parents AS \\\"documents_serialized.R1.dep_parents\\\", R1.font AS \\\"documents_serialized.R1.font\\\", R1.layout AS \\\"documents_serialized.R1.layout\\\"\\nFROM taxon_per_doc R0, documents_serialized R1\\n        WHERE R1.docid = R0.docid '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_taxon_per_doc\",\"ext_documents_serialized\"],\"input_relations\":[\"taxon_per_doc\",\"documents_serialized\"],\"output_relation\":\"document_with_taxon_entities\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_taxon_per_doc\",\"process/ext_documents_serialized\"],\"input_\":[\"data/taxon_per_doc\",\"data/documents_serialized\"],\"output_\":\"data/document_with_taxon_entities\",\"name\":\"process/ext_document_with_taxon_entities\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_document_with_taxon_entities'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"document_with_taxon_entities\"\n\tdeepdive sql 'INSERT INTO document_with_taxon_entities SELECT R0.docid AS \"taxon_per_doc.R0.docid\", array_to_string(R0.entity, '\\''@@@@@'\\'') AS column_1, array_to_string(R0.type, '\\''@@@@@'\\'') AS column_2, R1.sentids AS \"documents_serialized.R1.sentids\", R1.wordidxs AS \"documents_serialized.R1.wordidxs\", R1.words AS \"documents_serialized.R1.words\", R1.poses AS \"documents_serialized.R1.poses\", R1.ners AS \"documents_serialized.R1.ners\", R1.lemmas AS \"documents_serialized.R1.lemmas\", R1.dep_paths AS \"documents_serialized.R1.dep_paths\", R1.dep_parents AS \"documents_serialized.R1.dep_parents\", R1.font AS \"documents_serialized.R1.font\", R1.layout AS \"documents_serialized.R1.layout\"\nFROM taxon_per_doc R0, documents_serialized R1\n        WHERE R1.docid = R0.docid '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_documents/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_documents\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"documents\\\"\\n\\tdeepdive sql 'INSERT INTO documents SELECT DISTINCT R0.docid AS \\\"sentences_serialized.R0.docid\\\", ARRAY_AGG(R0.sentid) AS column_1, ARRAY_AGG(R0.wordidxs) AS column_2, ARRAY_AGG(R0.words) AS column_3, ARRAY_AGG(R0.poses) AS column_4, ARRAY_AGG(R0.ners) AS column_5, ARRAY_AGG(R0.lemmas) AS column_6, ARRAY_AGG(R0.dep_paths) AS column_7, ARRAY_AGG(R0.dep_parents) AS column_8, ARRAY_AGG(R0.font) AS column_9, ARRAY_AGG(R0.layout) AS column_10\\nFROM sentences_serialized R0\\n        \\n        GROUP BY R0.docid'\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_sentences_serialized\"],\"input_relations\":[\"sentences_serialized\"],\"output_relation\":\"documents\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_sentences_serialized\"],\"input_\":[\"data/sentences_serialized\"],\"output_\":\"data/documents\",\"name\":\"process/ext_documents\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_documents'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"documents\"\n\tdeepdive sql 'INSERT INTO documents SELECT DISTINCT R0.docid AS \"sentences_serialized.R0.docid\", ARRAY_AGG(R0.sentid) AS column_1, ARRAY_AGG(R0.wordidxs) AS column_2, ARRAY_AGG(R0.words) AS column_3, ARRAY_AGG(R0.poses) AS column_4, ARRAY_AGG(R0.ners) AS column_5, ARRAY_AGG(R0.lemmas) AS column_6, ARRAY_AGG(R0.dep_paths) AS column_7, ARRAY_AGG(R0.dep_parents) AS column_8, ARRAY_AGG(R0.font) AS column_9, ARRAY_AGG(R0.layout) AS column_10\nFROM sentences_serialized R0\n        \n        GROUP BY R0.docid'\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_documents_serialized/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_documents_serialized\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"documents_serialized\\\"\\n\\tdeepdive sql 'INSERT INTO documents_serialized SELECT R0.docid AS \\\"documents.R0.docid\\\", array_to_string(R0.sentids, '\\\\''|||||'\\\\'') AS column_1, array_to_string(R0.wordidxs, '\\\\''|||||'\\\\'') AS column_2, array_to_string(R0.words, '\\\\''|||||'\\\\'') AS column_3, array_to_string(R0.poses, '\\\\''|||||'\\\\'') AS column_4, array_to_string(R0.ners, '\\\\''|||||'\\\\'') AS column_5, array_to_string(R0.lemmas, '\\\\''|||||'\\\\'') AS column_6, array_to_string(R0.dep_paths, '\\\\''|||||'\\\\'') AS column_7, array_to_string(R0.dep_parents, '\\\\''|||||'\\\\'') AS column_8, array_to_string(R0.font, '\\\\''|||||'\\\\'') AS column_9, array_to_string(R0.layout, '\\\\''|||||'\\\\'') AS column_10\\nFROM documents R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_documents\"],\"input_relations\":[\"documents\"],\"output_relation\":\"documents_serialized\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_documents\"],\"input_\":[\"data/documents\"],\"output_\":\"data/documents_serialized\",\"name\":\"process/ext_documents_serialized\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_documents_serialized'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"documents_serialized\"\n\tdeepdive sql 'INSERT INTO documents_serialized SELECT R0.docid AS \"documents.R0.docid\", array_to_string(R0.sentids, '\\''|||||'\\'') AS column_1, array_to_string(R0.wordidxs, '\\''|||||'\\'') AS column_2, array_to_string(R0.words, '\\''|||||'\\'') AS column_3, array_to_string(R0.poses, '\\''|||||'\\'') AS column_4, array_to_string(R0.ners, '\\''|||||'\\'') AS column_5, array_to_string(R0.lemmas, '\\''|||||'\\'') AS column_6, array_to_string(R0.dep_paths, '\\''|||||'\\'') AS column_7, array_to_string(R0.dep_parents, '\\''|||||'\\'') AS column_8, array_to_string(R0.font, '\\''|||||'\\'') AS column_9, array_to_string(R0.layout, '\\''|||||'\\'') AS column_10\nFROM documents R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_entity_formation/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_entity_formation\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"entity_formation\\\"\\n\\tdeepdive sql 'INSERT INTO entity_formation SELECT R0.docid AS \\\"entity_formation_candidate.R0.docid\\\", R0.type AS \\\"entity_formation_candidate.R0.type\\\", R0.eid AS \\\"entity_formation_candidate.R0.eid\\\", R0.entity AS \\\"entity_formation_candidate.R0.entity\\\", R0.prov AS \\\"entity_formation_candidate.R0.prov\\\"\\nFROM entity_formation_candidate R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_formation_candidate\"],\"input_relations\":[\"entity_formation_candidate\"],\"output_relation\":\"entity_formation\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_formation_candidate\"],\"input_\":[\"data/entity_formation_candidate\"],\"output_\":\"data/entity_formation\",\"name\":\"process/ext_entity_formation\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_entity_formation'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"entity_formation\"\n\tdeepdive sql 'INSERT INTO entity_formation SELECT R0.docid AS \"entity_formation_candidate.R0.docid\", R0.type AS \"entity_formation_candidate.R0.type\", R0.eid AS \"entity_formation_candidate.R0.eid\", R0.entity AS \"entity_formation_candidate.R0.entity\", R0.prov AS \"entity_formation_candidate.R0.prov\"\nFROM entity_formation_candidate R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_entity_formation_candidate/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_entity_formation_candidate\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"entity_formation_candidate\\\"\\n\\tdeepdive sql 'INSERT INTO entity_formation_candidate SELECT R0.docid AS \\\"entity_formation_candidate__0.R0.docid\\\", R0.type AS \\\"entity_formation_candidate__0.R0.type\\\", R0.eid AS \\\"entity_formation_candidate__0.R0.eid\\\", R0.entity AS \\\"entity_formation_candidate__0.R0.entity\\\", R0.prov AS \\\"entity_formation_candidate__0.R0.prov\\\"\\nFROM entity_formation_candidate__0 R0\\n        \\nUNION ALL\\nSELECT R0.docid AS \\\"entity_formation_candidate_local.R0.docid\\\", R0.type AS \\\"entity_formation_candidate_local.R0.type\\\", R0.eid AS \\\"entity_formation_candidate_local.R0.eid\\\", R0.entity AS \\\"entity_formation_candidate_local.R0.entity\\\", R0.prov AS \\\"entity_formation_candidate_local.R0.prov\\\"\\nFROM entity_formation_candidate_local R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_formation_candidate__0_by_ext_entity_formation_global\",\"ext_entity_formation_candidate_local_by_ext_entity_formation_local\"],\"input_relations\":[\"entity_formation_candidate__0\",\"entity_formation_candidate_local\"],\"output_relation\":\"entity_formation_candidate\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_formation_candidate__0_by_ext_entity_formation_global\",\"process/ext_entity_formation_candidate_local_by_ext_entity_formation_local\"],\"input_\":[\"data/entity_formation_candidate__0\",\"data/entity_formation_candidate_local\"],\"output_\":\"data/entity_formation_candidate\",\"name\":\"process/ext_entity_formation_candidate\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_entity_formation_candidate'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"entity_formation_candidate\"\n\tdeepdive sql 'INSERT INTO entity_formation_candidate SELECT R0.docid AS \"entity_formation_candidate__0.R0.docid\", R0.type AS \"entity_formation_candidate__0.R0.type\", R0.eid AS \"entity_formation_candidate__0.R0.eid\", R0.entity AS \"entity_formation_candidate__0.R0.entity\", R0.prov AS \"entity_formation_candidate__0.R0.prov\"\nFROM entity_formation_candidate__0 R0\n        \nUNION ALL\nSELECT R0.docid AS \"entity_formation_candidate_local.R0.docid\", R0.type AS \"entity_formation_candidate_local.R0.type\", R0.eid AS \"entity_formation_candidate_local.R0.eid\", R0.entity AS \"entity_formation_candidate_local.R0.entity\", R0.prov AS \"entity_formation_candidate_local.R0.prov\"\nFROM entity_formation_candidate_local R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_entity_location/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_entity_location\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"entity_location\\\"\\n\\tdeepdive sql 'INSERT INTO entity_location SELECT R0.docid AS \\\"entity_location_candidate.R0.docid\\\", R0.type AS \\\"entity_location_candidate.R0.type\\\", R0.eid AS \\\"entity_location_candidate.R0.eid\\\", R0.entity AS \\\"entity_location_candidate.R0.entity\\\", R0.prov AS \\\"entity_location_candidate.R0.prov\\\"\\nFROM entity_location_candidate R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_location_candidate_by_ext_entity_location_global\"],\"input_relations\":[\"entity_location_candidate\"],\"output_relation\":\"entity_location\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_location_candidate_by_ext_entity_location_global\"],\"input_\":[\"data/entity_location_candidate\"],\"output_\":\"data/entity_location\",\"name\":\"process/ext_entity_location\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_entity_location'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"entity_location\"\n\tdeepdive sql 'INSERT INTO entity_location SELECT R0.docid AS \"entity_location_candidate.R0.docid\", R0.type AS \"entity_location_candidate.R0.type\", R0.eid AS \"entity_location_candidate.R0.eid\", R0.entity AS \"entity_location_candidate.R0.entity\", R0.prov AS \"entity_location_candidate.R0.prov\"\nFROM entity_location_candidate R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_entity_taxon/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_entity_taxon\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"entity_taxon\\\"\\n\\tdeepdive sql 'INSERT INTO entity_taxon SELECT R0.docid AS \\\"entity_taxon_candidate.R0.docid\\\", R0.type AS \\\"entity_taxon_candidate.R0.type\\\", R0.eid AS \\\"entity_taxon_candidate.R0.eid\\\", R0.entity AS \\\"entity_taxon_candidate.R0.entity\\\", R0.author_year AS \\\"entity_taxon_candidate.R0.author_year\\\", R0.prov AS \\\"entity_taxon_candidate.R0.prov\\\"\\nFROM entity_taxon_candidate R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_taxon_candidate\"],\"input_relations\":[\"entity_taxon_candidate\"],\"output_relation\":\"entity_taxon\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_taxon_candidate\"],\"input_\":[\"data/entity_taxon_candidate\"],\"output_\":\"data/entity_taxon\",\"name\":\"process/ext_entity_taxon\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_entity_taxon'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"entity_taxon\"\n\tdeepdive sql 'INSERT INTO entity_taxon SELECT R0.docid AS \"entity_taxon_candidate.R0.docid\", R0.type AS \"entity_taxon_candidate.R0.type\", R0.eid AS \"entity_taxon_candidate.R0.eid\", R0.entity AS \"entity_taxon_candidate.R0.entity\", R0.author_year AS \"entity_taxon_candidate.R0.author_year\", R0.prov AS \"entity_taxon_candidate.R0.prov\"\nFROM entity_taxon_candidate R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_entity_taxon_candidate/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_entity_taxon_candidate\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"entity_taxon_candidate\\\"\\n\\tdeepdive sql 'INSERT INTO entity_taxon_candidate SELECT R0.docid AS \\\"entity_taxon_candidate__0.R0.docid\\\", R0.type AS \\\"entity_taxon_candidate__0.R0.type\\\", R0.eid AS \\\"entity_taxon_candidate__0.R0.eid\\\", R0.entity AS \\\"entity_taxon_candidate__0.R0.entity\\\", R0.author_year AS \\\"entity_taxon_candidate__0.R0.author_year\\\", R0.prov AS \\\"entity_taxon_candidate__0.R0.prov\\\"\\nFROM entity_taxon_candidate__0 R0\\n        \\nUNION ALL\\nSELECT R0.docid AS \\\"entity_taxon_candidate_local.R0.docid\\\", R0.type AS \\\"entity_taxon_candidate_local.R0.type\\\", R0.eid AS \\\"entity_taxon_candidate_local.R0.eid\\\", R0.entity AS \\\"entity_taxon_candidate_local.R0.entity\\\", R0.author_year AS \\\"entity_taxon_candidate_local.R0.author_year\\\", R0.prov AS \\\"entity_taxon_candidate_local.R0.prov\\\"\\nFROM entity_taxon_candidate_local R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_taxon_candidate__0_by_ext_entity_taxon_global\",\"ext_entity_taxon_candidate_local_by_ext_entity_taxon_local\"],\"input_relations\":[\"entity_taxon_candidate__0\",\"entity_taxon_candidate_local\"],\"output_relation\":\"entity_taxon_candidate\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_taxon_candidate__0_by_ext_entity_taxon_global\",\"process/ext_entity_taxon_candidate_local_by_ext_entity_taxon_local\"],\"input_\":[\"data/entity_taxon_candidate__0\",\"data/entity_taxon_candidate_local\"],\"output_\":\"data/entity_taxon_candidate\",\"name\":\"process/ext_entity_taxon_candidate\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_entity_taxon_candidate'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"entity_taxon_candidate\"\n\tdeepdive sql 'INSERT INTO entity_taxon_candidate SELECT R0.docid AS \"entity_taxon_candidate__0.R0.docid\", R0.type AS \"entity_taxon_candidate__0.R0.type\", R0.eid AS \"entity_taxon_candidate__0.R0.eid\", R0.entity AS \"entity_taxon_candidate__0.R0.entity\", R0.author_year AS \"entity_taxon_candidate__0.R0.author_year\", R0.prov AS \"entity_taxon_candidate__0.R0.prov\"\nFROM entity_taxon_candidate__0 R0\n        \nUNION ALL\nSELECT R0.docid AS \"entity_taxon_candidate_local.R0.docid\", R0.type AS \"entity_taxon_candidate_local.R0.type\", R0.eid AS \"entity_taxon_candidate_local.R0.eid\", R0.entity AS \"entity_taxon_candidate_local.R0.entity\", R0.author_year AS \"entity_taxon_candidate_local.R0.author_year\", R0.prov AS \"entity_taxon_candidate_local.R0.prov\"\nFROM entity_taxon_candidate_local R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_entity_temporal/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_entity_temporal\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"entity_temporal\\\"\\n\\tdeepdive sql 'INSERT INTO entity_temporal SELECT R0.docid AS \\\"entity_temporal_candidate.R0.docid\\\", R0.type AS \\\"entity_temporal_candidate.R0.type\\\", R0.eid AS \\\"entity_temporal_candidate.R0.eid\\\", R0.entity AS \\\"entity_temporal_candidate.R0.entity\\\", R0.prov AS \\\"entity_temporal_candidate.R0.prov\\\"\\nFROM entity_temporal_candidate R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_temporal_candidate_by_ext_entity_temporal_local\"],\"input_relations\":[\"entity_temporal_candidate\"],\"output_relation\":\"entity_temporal\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_temporal_candidate_by_ext_entity_temporal_local\"],\"input_\":[\"data/entity_temporal_candidate\"],\"output_\":\"data/entity_temporal\",\"name\":\"process/ext_entity_temporal\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_entity_temporal'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"entity_temporal\"\n\tdeepdive sql 'INSERT INTO entity_temporal SELECT R0.docid AS \"entity_temporal_candidate.R0.docid\", R0.type AS \"entity_temporal_candidate.R0.type\", R0.eid AS \"entity_temporal_candidate.R0.eid\", R0.entity AS \"entity_temporal_candidate.R0.entity\", R0.prov AS \"entity_temporal_candidate.R0.prov\"\nFROM entity_temporal_candidate R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_formation_per_doc/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_formation_per_doc\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"formation_per_doc\\\"\\n\\tdeepdive sql 'INSERT INTO formation_per_doc SELECT R0.docid AS \\\"entity_formation_candidate_local.R0.docid\\\", ARRAY_AGG(R0.entity) AS column_1, ARRAY_AGG(R0.type) AS column_2\\nFROM entity_formation_candidate_local R0\\n        \\n        GROUP BY R0.docid'\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_formation_candidate_local_by_ext_entity_formation_local\"],\"input_relations\":[\"entity_formation_candidate_local\"],\"output_relation\":\"formation_per_doc\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_formation_candidate_local_by_ext_entity_formation_local\"],\"input_\":[\"data/entity_formation_candidate_local\"],\"output_\":\"data/formation_per_doc\",\"name\":\"process/ext_formation_per_doc\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_formation_per_doc'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"formation_per_doc\"\n\tdeepdive sql 'INSERT INTO formation_per_doc SELECT R0.docid AS \"entity_formation_candidate_local.R0.docid\", ARRAY_AGG(R0.entity) AS column_1, ARRAY_AGG(R0.type) AS column_2\nFROM entity_formation_candidate_local R0\n        \n        GROUP BY R0.docid'\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_relation_formation/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_relation_formation\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"relation_formation\\\"\\n\\tdeepdive sql 'INSERT INTO relation_formation SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 AS id, R0.label AS label\\n          FROM relation_formation_supervise R0\\n        \\n          '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_relation_formation_supervise_by_ext_relation_variable_formation\"],\"input_relations\":[\"relation_formation_supervise\"],\"output_relation\":\"relation_formation\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_relation_formation_supervise_by_ext_relation_variable_formation\"],\"input_\":[\"data/relation_formation_supervise\"],\"output_\":\"data/relation_formation\",\"name\":\"process/ext_relation_formation\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_relation_formation'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"relation_formation\"\n\tdeepdive sql 'INSERT INTO relation_formation SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 AS id, R0.label AS label\n          FROM relation_formation_supervise R0\n        \n          '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_relation_formation_global/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_relation_formation_global\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"relation_formation_global\\\"\\n\\tdeepdive sql 'INSERT INTO relation_formation_global SELECT DISTINCT R0.type AS \\\"relation_formation.R0.type\\\", R0.eid1 AS \\\"relation_formation.R0.eid1\\\", R0.eid2 AS \\\"relation_formation.R0.eid2\\\"\\nFROM relation_formation R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_relation_formation\"],\"input_relations\":[\"relation_formation\"],\"output_relation\":\"relation_formation_global\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_relation_formation\"],\"input_\":[\"data/relation_formation\"],\"output_\":\"data/relation_formation_global\",\"name\":\"process/ext_relation_formation_global\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_relation_formation_global'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"relation_formation_global\"\n\tdeepdive sql 'INSERT INTO relation_formation_global SELECT DISTINCT R0.type AS \"relation_formation.R0.type\", R0.eid1 AS \"relation_formation.R0.eid1\", R0.eid2 AS \"relation_formation.R0.eid2\"\nFROM relation_formation R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_relation_formationtemporal/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_relation_formationtemporal\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"relation_formationtemporal\\\"\\n\\tdeepdive sql 'INSERT INTO relation_formationtemporal SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 AS id, R0.label AS label\\n          FROM relation_formationtemporal_supervise R0\\n        \\n          '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_relation_formationtemporal_supervise_by_ext_relation_variable_formationtemporal\"],\"input_relations\":[\"relation_formationtemporal_supervise\"],\"output_relation\":\"relation_formationtemporal\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_relation_formationtemporal_supervise_by_ext_relation_variable_formationtemporal\"],\"input_\":[\"data/relation_formationtemporal_supervise\"],\"output_\":\"data/relation_formationtemporal\",\"name\":\"process/ext_relation_formationtemporal\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_relation_formationtemporal'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"relation_formationtemporal\"\n\tdeepdive sql 'INSERT INTO relation_formationtemporal SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 AS id, R0.label AS label\n          FROM relation_formationtemporal_supervise R0\n        \n          '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_relation_formationtemporal_global/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_relation_formationtemporal_global\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"relation_formationtemporal_global\\\"\\n\\tdeepdive sql 'INSERT INTO relation_formationtemporal_global SELECT DISTINCT R0.type AS \\\"relation_formationtemporal.R0.type\\\", R0.eid1 AS \\\"relation_formationtemporal.R0.eid1\\\", R0.eid2 AS \\\"relation_formationtemporal.R0.eid2\\\"\\nFROM relation_formationtemporal R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_relation_formationtemporal\"],\"input_relations\":[\"relation_formationtemporal\"],\"output_relation\":\"relation_formationtemporal_global\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_relation_formationtemporal\"],\"input_\":[\"data/relation_formationtemporal\"],\"output_\":\"data/relation_formationtemporal_global\",\"name\":\"process/ext_relation_formationtemporal_global\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_relation_formationtemporal_global'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"relation_formationtemporal_global\"\n\tdeepdive sql 'INSERT INTO relation_formationtemporal_global SELECT DISTINCT R0.type AS \"relation_formationtemporal.R0.type\", R0.eid1 AS \"relation_formationtemporal.R0.eid1\", R0.eid2 AS \"relation_formationtemporal.R0.eid2\"\nFROM relation_formationtemporal R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_relation_taxonomy/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_relation_taxonomy\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"relation_taxonomy\\\"\\n\\tdeepdive sql 'INSERT INTO relation_taxonomy SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 AS id, R0.label AS label\\n          FROM relation_taxonomy_supervise R0\\n        \\n          '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_relation_taxonomy_supervise_by_ext_relation_variable_taxonomy\"],\"input_relations\":[\"relation_taxonomy_supervise\"],\"output_relation\":\"relation_taxonomy\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_relation_taxonomy_supervise_by_ext_relation_variable_taxonomy\"],\"input_\":[\"data/relation_taxonomy_supervise\"],\"output_\":\"data/relation_taxonomy\",\"name\":\"process/ext_relation_taxonomy\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_relation_taxonomy'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"relation_taxonomy\"\n\tdeepdive sql 'INSERT INTO relation_taxonomy SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 AS id, R0.label AS label\n          FROM relation_taxonomy_supervise R0\n        \n          '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_relation_taxonomy_global/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_relation_taxonomy_global\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"relation_taxonomy_global\\\"\\n\\tdeepdive sql 'INSERT INTO relation_taxonomy_global SELECT DISTINCT R0.type AS \\\"relation_taxonomy.R0.type\\\", R0.eid1 AS \\\"relation_taxonomy.R0.eid1\\\", R0.eid2 AS \\\"relation_taxonomy.R0.eid2\\\"\\nFROM relation_taxonomy R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_relation_taxonomy\"],\"input_relations\":[\"relation_taxonomy\"],\"output_relation\":\"relation_taxonomy_global\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_relation_taxonomy\"],\"input_\":[\"data/relation_taxonomy\"],\"output_\":\"data/relation_taxonomy_global\",\"name\":\"process/ext_relation_taxonomy_global\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_relation_taxonomy_global'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"relation_taxonomy_global\"\n\tdeepdive sql 'INSERT INTO relation_taxonomy_global SELECT DISTINCT R0.type AS \"relation_taxonomy.R0.type\", R0.eid1 AS \"relation_taxonomy.R0.eid1\", R0.eid2 AS \"relation_taxonomy.R0.eid2\"\nFROM relation_taxonomy R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_sentences/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_sentences\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"sentences\\\"\\n\\tdeepdive sql 'INSERT INTO sentences SELECT R0.docid AS \\\"sentences_original.R0.docid\\\", R0.sentid AS \\\"sentences_original.R0.sentid\\\", R0.wordindex AS \\\"sentences_original.R0.wordindex\\\", R0.words AS \\\"sentences_original.R0.words\\\", R0.poses AS \\\"sentences_original.R0.poses\\\", R0.ners AS \\\"sentences_original.R0.ners\\\", R0.lemmas AS \\\"sentences_original.R0.lemmas\\\", R0.dep_paths AS \\\"sentences_original.R0.dep_paths\\\", R0.dep_parents AS \\\"sentences_original.R0.dep_parents\\\", NULL AS column_9, NULL AS column_9\\nFROM sentences_original R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"input_relations\":[\"sentences_original\"],\"output_relation\":\"sentences\",\"style\":\"cmd_extractor\",\"dependencies_\":[],\"input_\":[\"data/sentences_original\"],\"output_\":\"data/sentences\",\"name\":\"process/ext_sentences\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_sentences'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"sentences\"\n\tdeepdive sql 'INSERT INTO sentences SELECT R0.docid AS \"sentences_original.R0.docid\", R0.sentid AS \"sentences_original.R0.sentid\", R0.wordindex AS \"sentences_original.R0.wordindex\", R0.words AS \"sentences_original.R0.words\", R0.poses AS \"sentences_original.R0.poses\", R0.ners AS \"sentences_original.R0.ners\", R0.lemmas AS \"sentences_original.R0.lemmas\", R0.dep_paths AS \"sentences_original.R0.dep_paths\", R0.dep_parents AS \"sentences_original.R0.dep_parents\", NULL AS column_9, NULL AS column_9\nFROM sentences_original R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_sentences_serialized/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_sentences_serialized\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"sentences_serialized\\\"\\n\\tdeepdive sql 'INSERT INTO sentences_serialized SELECT DISTINCT R0.docid AS \\\"sentences.R0.docid\\\", R0.sentid AS \\\"sentences.R0.sentid\\\", array_to_string(R0.wordindex, '\\\\''@@@@@'\\\\'') AS column_2, array_to_string(R0.words, '\\\\''@@@@@'\\\\'') AS column_3, array_to_string(R0.poses, '\\\\''@@@@@'\\\\'') AS column_4, array_to_string(R0.ners, '\\\\''@@@@@'\\\\'') AS column_5, array_to_string(R0.lemmas, '\\\\''@@@@@'\\\\'') AS column_6, array_to_string(R0.dep_paths, '\\\\''@@@@@'\\\\'') AS column_7, array_to_string(R0.dep_parents, '\\\\''@@@@@'\\\\'') AS column_8, array_to_string(R0.font, '\\\\''@@@@@'\\\\'') AS column_9, array_to_string(R0.layout, '\\\\''@@@@@'\\\\'') AS column_10\\nFROM sentences R0\\n        '\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_sentences\"],\"input_relations\":[\"sentences\"],\"output_relation\":\"sentences_serialized\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_sentences\"],\"input_\":[\"data/sentences\"],\"output_\":\"data/sentences_serialized\",\"name\":\"process/ext_sentences_serialized\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_sentences_serialized'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"sentences_serialized\"\n\tdeepdive sql 'INSERT INTO sentences_serialized SELECT DISTINCT R0.docid AS \"sentences.R0.docid\", R0.sentid AS \"sentences.R0.sentid\", array_to_string(R0.wordindex, '\\''@@@@@'\\'') AS column_2, array_to_string(R0.words, '\\''@@@@@'\\'') AS column_3, array_to_string(R0.poses, '\\''@@@@@'\\'') AS column_4, array_to_string(R0.ners, '\\''@@@@@'\\'') AS column_5, array_to_string(R0.lemmas, '\\''@@@@@'\\'') AS column_6, array_to_string(R0.dep_paths, '\\''@@@@@'\\'') AS column_7, array_to_string(R0.dep_parents, '\\''@@@@@'\\'') AS column_8, array_to_string(R0.font, '\\''@@@@@'\\'') AS column_9, array_to_string(R0.layout, '\\''@@@@@'\\'') AS column_10\nFROM sentences R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/ext_taxon_per_doc/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/ext_taxon_per_doc\n# {\"cmd\":\"\\n\\n\\t# TODO use temporary table\\n\\tdeepdive create table \\\"taxon_per_doc\\\"\\n\\tdeepdive sql 'INSERT INTO taxon_per_doc SELECT R0.docid AS \\\"entity_taxon_candidate_local.R0.docid\\\", ARRAY_AGG(R0.entity) AS column_1, ARRAY_AGG(R0.type) AS column_2\\nFROM entity_taxon_candidate_local R0\\n        \\n        GROUP BY R0.docid'\\n\\t# TODO rename temporary table to replace output_relation\\n\\t\\n        \",\"dependencies\":[\"ext_entity_taxon_candidate_local_by_ext_entity_taxon_local\"],\"input_relations\":[\"entity_taxon_candidate_local\"],\"output_relation\":\"taxon_per_doc\",\"style\":\"cmd_extractor\",\"dependencies_\":[\"process/ext_entity_taxon_candidate_local_by_ext_entity_taxon_local\"],\"input_\":[\"data/entity_taxon_candidate_local\"],\"output_\":\"data/taxon_per_doc\",\"name\":\"process/ext_taxon_per_doc\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/ext_taxon_per_doc'\n\n\n\t# TODO use temporary table\n\tdeepdive create table \"taxon_per_doc\"\n\tdeepdive sql 'INSERT INTO taxon_per_doc SELECT R0.docid AS \"entity_taxon_candidate_local.R0.docid\", ARRAY_AGG(R0.entity) AS column_1, ARRAY_AGG(R0.type) AS column_2\nFROM entity_taxon_candidate_local R0\n        \n        GROUP BY R0.docid'\n\t# TODO rename temporary table to replace output_relation\n\t\n        \n\n\n"
}
{
  "path": "process/grounding/variable_id_partition/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable_id_partition\n# {\"dependencies_\":[\"data/entity_formation\",\"data/entity_location\",\"data/entity_taxon\",\"data/entity_temporal\",\"data/relation_formation\",\"data/relation_formation_global\",\"data/relation_formationtemporal\",\"data/relation_formationtemporal_global\",\"data/relation_taxonomy\",\"data/relation_taxonomy_global\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n        RANGE_BEGIN=0 \\\\\\n        partition_id_range 'entity_formation' 'entity_location' 'entity_taxon' 'entity_temporal' 'relation_formation' 'relation_formation_global' 'relation_formationtemporal' 'relation_formationtemporal_global' 'relation_taxonomy' 'relation_taxonomy_global' | {\\n            # record the base\\n            variableCountTotal=0\\n            while read table begin excludeEnd; do\\n                varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n                mkdir -p \\\"$varPath\\\"\\n                cd \\\"$varPath\\\"\\n                echo $begin                      >id_begin\\n                echo $excludeEnd                 >id_exclude_end\\n                echo $(( $excludeEnd - $begin )) >count\\n                variableCountTotal=$excludeEnd\\n            done\\n            # record the final count\\n            echo $variableCountTotal >\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable_count\\n        }\\n        \",\"name\":\"process/grounding/variable_id_partition\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable_id_partition'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        RANGE_BEGIN=0 \\\n        partition_id_range 'entity_formation' 'entity_location' 'entity_taxon' 'entity_temporal' 'relation_formation' 'relation_formation_global' 'relation_formationtemporal' 'relation_formationtemporal_global' 'relation_taxonomy' 'relation_taxonomy_global' | {\n            # record the base\n            variableCountTotal=0\n            while read table begin excludeEnd; do\n                varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n                mkdir -p \"$varPath\"\n                cd \"$varPath\"\n                echo $begin                      >id_begin\n                echo $excludeEnd                 >id_exclude_end\n                echo $(( $excludeEnd - $begin )) >count\n                variableCountTotal=$excludeEnd\n            done\n            # record the final count\n            echo $variableCountTotal >\"$DEEPDIVE_GROUNDING_DIR\"/variable_count\n        }\n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_formation/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_formation/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_formation'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/entity_formation/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_formation/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_formation'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_location/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_location/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_location'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/entity_location/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_location/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_location'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_taxon/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_taxon/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_taxon'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/entity_taxon/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_taxon/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_taxon'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_temporal/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_temporal/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_temporal'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/entity_temporal/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_temporal/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_temporal'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formation/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formation/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formation'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/relation_formation/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formation/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formation'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formation_global/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formation_global/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formation_global'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/relation_formation_global/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formation_global/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formation_global'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formationtemporal/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formationtemporal/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formationtemporal'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/relation_formationtemporal/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formationtemporal/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formationtemporal'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formationtemporal_global/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formationtemporal_global/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formationtemporal_global'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/relation_formationtemporal_global/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formationtemporal_global/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formationtemporal_global'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_taxonomy/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_taxonomy/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_taxonomy'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/relation_taxonomy/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_taxonomy/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_taxonomy'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_taxonomy_global/assign_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_taxonomy_global/assign_id\n# {\"dependencies_\":[\"process/grounding/variable_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_taxonomy_global'\\n\\n        cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/${table}\\n        baseId=$(cat id_begin)\\n\\n        # assign id to all rows according to the paritition\\n        deepdive db assign_sequential_id $table 'id' $baseId\\n\\n        \\n        \",\"name\":\"process/grounding/variable/relation_taxonomy_global/assign_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_taxonomy_global/assign_id'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_taxonomy_global'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        \n\n\n"
}
{
  "path": "process/grounding/variable_holdout/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable_holdout\n# {\"dependencies_\":[\"process/grounding/variable/entity_formation/assign_id\",\"process/grounding/variable/entity_location/assign_id\",\"process/grounding/variable/entity_taxon/assign_id\",\"process/grounding/variable/entity_temporal/assign_id\",\"process/grounding/variable/relation_formation/assign_id\",\"process/grounding/variable/relation_formation_global/assign_id\",\"process/grounding/variable/relation_formationtemporal/assign_id\",\"process/grounding/variable/relation_formationtemporal_global/assign_id\",\"process/grounding/variable/relation_taxonomy/assign_id\",\"process/grounding/variable/relation_taxonomy_global/assign_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n        deepdive create table 'dd_graph_variables_holdout' \\\\\\n            variable_id:BIGINT:'PRIMARY KEY' \\\\\\n            #\\n        deepdive create table 'dd_graph_variables_observation' \\\\\\n            variable_id:BIGINT:'PRIMARY KEY' \\\\\\n            #\\n        deepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"entity_formation\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"entity_location\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"entity_taxon\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"entity_temporal\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"relation_formation\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"relation_formation_global\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"relation_formationtemporal\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"relation_formationtemporal_global\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"relation_taxonomy\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\ndeepdive sql '\\n                INSERT INTO \\\"dd_graph_variables_holdout\\\" SELECT \\\"id\\\"\\nFROM \\\"relation_taxonomy_global\\\"\\n\\nWHERE \\\"label\\\" IS NOT NULL AND RANDOM() < null;\\n            '\\n        \",\"name\":\"process/grounding/variable_holdout\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable_holdout'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        deepdive create table 'dd_graph_variables_holdout' \\\n            variable_id:BIGINT:'PRIMARY KEY' \\\n            #\n        deepdive create table 'dd_graph_variables_observation' \\\n            variable_id:BIGINT:'PRIMARY KEY' \\\n            #\n        deepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"entity_formation\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"entity_location\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"entity_taxon\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"entity_temporal\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"relation_formation\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"relation_formation_global\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"relation_formationtemporal\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"relation_formationtemporal_global\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"relation_taxonomy\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\ndeepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"relation_taxonomy_global\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < null;\n            '\n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_formation/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_formation/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_formation'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'entity_formation'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"entity_formation\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/entity_formation/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_formation/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_formation'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'entity_formation'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"entity_formation\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_location/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_location/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_location'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'entity_location'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"entity_location\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/entity_location/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_location/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_location'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'entity_location'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"entity_location\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_taxon/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_taxon/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_taxon'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'entity_taxon'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"entity_taxon\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/entity_taxon/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_taxon/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_taxon'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'entity_taxon'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"entity_taxon\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/entity_temporal/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/entity_temporal/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='entity_temporal'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'entity_temporal'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"entity_temporal\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/entity_temporal/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/entity_temporal/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='entity_temporal'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'entity_temporal'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"entity_temporal\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formation/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formation/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formation'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'relation_formation'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"relation_formation\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/relation_formation/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formation/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formation'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'relation_formation'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"relation_formation\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formation_global/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formation_global/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formation_global'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'relation_formation_global'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"relation_formation_global\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/relation_formation_global/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formation_global/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formation_global'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'relation_formation_global'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"relation_formation_global\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formationtemporal/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formationtemporal/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formationtemporal'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'relation_formationtemporal'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"relation_formationtemporal\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/relation_formationtemporal/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formationtemporal/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formationtemporal'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'relation_formationtemporal'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"relation_formationtemporal\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_formationtemporal_global/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_formationtemporal_global/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_formationtemporal_global'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'relation_formationtemporal_global'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"relation_formationtemporal_global\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/relation_formationtemporal_global/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_formationtemporal_global/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_formationtemporal_global'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'relation_formationtemporal_global'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"relation_formationtemporal_global\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_taxonomy/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_taxonomy/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_taxonomy'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'relation_taxonomy'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"relation_taxonomy\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/relation_taxonomy/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_taxonomy/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_taxonomy'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'relation_taxonomy'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"relation_taxonomy\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/variable/relation_taxonomy_global/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/variable/relation_taxonomy_global/dump\n# {\"dependencies_\":[\"process/grounding/variable_holdout\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        table='relation_taxonomy_global'\\n\\n        varPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/'relation_taxonomy_global'\\n        mkdir -p \\\"$varPath\\\"\\n        cd \\\"$varPath\\\"\\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\\n        export DEEPDIVE_LOAD_FORMAT=tsv\\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n        # dump the variables, joining the holdout query to determine the type of each variable\\n        deepdive compute execute \\\\\\n            input_sql='SELECT \\\"id\\\"\\n     , \\\"variable_role\\\"\\n     , CASE WHEN variable_role = 0 THEN 0\\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\\n                      END AS \\\"init_value\\\"\\n     , \\\"variable_type\\\"\\n     , \\\"cardinality\\\"\\nFROM (SELECT \\\"id\\\" AS \\\"id\\\"\\n     , CASE WHEN               observation.variable_id IS NOT NULL\\n                                     AND variables.\\\"label\\\" IS NOT NULL THEN 2\\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\\n                                    WHEN variables.\\\"label\\\" IS NOT NULL THEN 1\\n                                                                                       ELSE 0\\n                                END AS \\\"variable_role\\\"\\n     , \\\"variables\\\".\\\"label\\\" AS \\\"label\\\"\\n     , 0 AS \\\"variable_type\\\"\\n     , 2 AS \\\"cardinality\\\"\\nFROM \\\"relation_taxonomy_global\\\" \\\"variables\\\"\\nLEFT OUTER JOIN \\\"dd_graph_variables_holdout\\\" \\\"holdout\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"holdout\\\".\\\"variable_id\\\" LEFT OUTER JOIN \\\"dd_graph_variables_observation\\\" \\\"observation\\\" ON \\\"variables\\\".\\\"id\\\" = \\\"observation\\\".\\\"variable_id\\\") \\\"variables\\\"' \\\\\\n            command='\\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n            ' \\\\\\n            output_relation=\\n        \",\"name\":\"process/grounding/variable/relation_taxonomy_global/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/variable/relation_taxonomy_global/dump'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='relation_taxonomy_global'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'relation_taxonomy_global'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"relation_taxonomy_global\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_formation/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_formation/materialize\n# {\"dependencies_\":[\"process/grounding/variable/entity_formation/assign_id\"],\"input_\":[\"data/entity_formation_candidate\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_entity_formation' as '\\n          SELECT R0.id AS \\\"entity_formation.R0.id\\\" , R0.type AS \\\"dd_weight_column_0\\\" \\n          FROM entity_formation R0, entity_formation_candidate R1\\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_entity_formation' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_formation\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_formation/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_formation/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_entity_formation' as '\n          SELECT R0.id AS \"entity_formation.R0.id\" , R0.type AS \"dd_weight_column_0\" \n          FROM entity_formation R0, entity_formation_candidate R1\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_entity_formation' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_entity_formation\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_location/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_location/materialize\n# {\"dependencies_\":[\"process/grounding/variable/entity_location/assign_id\"],\"input_\":[\"data/entity_location_candidate\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_entity_location' as '\\n          SELECT R0.id AS \\\"entity_location.R0.id\\\" , R0.type AS \\\"dd_weight_column_0\\\" \\n          FROM entity_location R0, entity_location_candidate R1\\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_entity_location' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_location\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_location/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_location/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_entity_location' as '\n          SELECT R0.id AS \"entity_location.R0.id\" , R0.type AS \"dd_weight_column_0\" \n          FROM entity_location R0, entity_location_candidate R1\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_entity_location' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_entity_location\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_taxon/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_taxon/materialize\n# {\"dependencies_\":[\"process/grounding/variable/entity_taxon/assign_id\"],\"input_\":[\"data/entity_taxon_candidate\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_entity_taxon' as '\\n          SELECT R0.id AS \\\"entity_taxon.R0.id\\\" , R0.type AS \\\"dd_weight_column_0\\\" \\n          FROM entity_taxon R0, entity_taxon_candidate R1\\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.author_year = R0.author_year  AND R1.prov = R0.prov '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_entity_taxon' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_taxon\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_taxon/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_taxon/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_entity_taxon' as '\n          SELECT R0.id AS \"entity_taxon.R0.id\" , R0.type AS \"dd_weight_column_0\" \n          FROM entity_taxon R0, entity_taxon_candidate R1\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.author_year = R0.author_year  AND R1.prov = R0.prov '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_entity_taxon' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_entity_taxon\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_temporal/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_temporal/materialize\n# {\"dependencies_\":[\"process/grounding/variable/entity_temporal/assign_id\"],\"input_\":[\"data/entity_temporal_candidate\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_entity_temporal' as '\\n          SELECT R0.id AS \\\"entity_temporal.R0.id\\\" , R0.type AS \\\"dd_weight_column_0\\\" \\n          FROM entity_temporal R0, entity_temporal_candidate R1\\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_entity_temporal' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_temporal\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_temporal/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_temporal/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_entity_temporal' as '\n          SELECT R0.id AS \"entity_temporal.R0.id\" , R0.type AS \"dd_weight_column_0\" \n          FROM entity_temporal R0, entity_temporal_candidate R1\n        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_entity_temporal' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_entity_temporal\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation/materialize\n# {\"dependencies_\":[\"process/grounding/variable/relation_formation/assign_id\"],\"input_\":[\"data/relation_candidates\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_relation_formation' as '\\n          SELECT R0.id AS \\\"relation_formation.R0.id\\\" , R1.features AS \\\"dd_weight_column_0\\\" \\n          FROM relation_formation R0, relation_candidates R1\\n        WHERE R1.docid = R0.docid  AND R1.type = '\\\\''FORMATION'\\\\'' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2 '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_relation_formation' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formation\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_relation_formation' as '\n          SELECT R0.id AS \"relation_formation.R0.id\" , R1.features AS \"dd_weight_column_0\" \n          FROM relation_formation R0, relation_candidates R1\n        WHERE R1.docid = R0.docid  AND R1.type = '\\''FORMATION'\\'' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2 '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_relation_formation' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_relation_formation\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation_global/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation_global/materialize\n# {\"dependencies_\":[\"process/grounding/variable/relation_formation_global/assign_id\",\"process/grounding/variable/relation_formation/assign_id\"],\"input_\":[\"data/relation_candidates\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_relation_formation_global' as '\\n          SELECT R0.id AS \\\"relation_formation_global.R0.id\\\" , R1.id AS \\\"relation_formation.R1.id\\\" , R2.features AS \\\"dd_weight_column_0\\\" \\n          FROM relation_formation_global R0, relation_formation R1, relation_candidates R2\\n        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2 '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_relation_formation_global' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formation_global\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation_global/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation_global/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_relation_formation_global' as '\n          SELECT R0.id AS \"relation_formation_global.R0.id\" , R1.id AS \"relation_formation.R1.id\" , R2.features AS \"dd_weight_column_0\" \n          FROM relation_formation_global R0, relation_formation R1, relation_candidates R2\n        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2 '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_relation_formation_global' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_relation_formation_global\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal/materialize\n# {\"dependencies_\":[\"process/grounding/variable/relation_formationtemporal/assign_id\",\"process/grounding/variable/entity_formation/assign_id\",\"process/grounding/variable/entity_temporal/assign_id\"],\"input_\":[\"data/relation_candidates\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_relation_formationtemporal' as '\\n          SELECT R0.id AS \\\"relation_formationtemporal.R0.id\\\" , R2.id AS \\\"entity_formation.R2.id\\\" , R3.id AS \\\"entity_temporal.R3.id\\\" , R1.features AS \\\"dd_weight_column_0\\\" \\n          FROM relation_formationtemporal R0, relation_candidates R1, entity_formation R2, entity_temporal R3\\n        WHERE R1.docid = R0.docid  AND R1.type = '\\\\''FORMATIONINTERVAL'\\\\'' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2  AND R2.docid = R0.docid  AND R2.eid = R0.eid1  AND R2.entity = R0.entity1  AND R3.docid = R0.docid  AND R3.eid = R0.eid2  AND R3.entity = R0.entity2 '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_relation_formationtemporal' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formationtemporal\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_relation_formationtemporal' as '\n          SELECT R0.id AS \"relation_formationtemporal.R0.id\" , R2.id AS \"entity_formation.R2.id\" , R3.id AS \"entity_temporal.R3.id\" , R1.features AS \"dd_weight_column_0\" \n          FROM relation_formationtemporal R0, relation_candidates R1, entity_formation R2, entity_temporal R3\n        WHERE R1.docid = R0.docid  AND R1.type = '\\''FORMATIONINTERVAL'\\'' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2  AND R2.docid = R0.docid  AND R2.eid = R0.eid1  AND R2.entity = R0.entity1  AND R3.docid = R0.docid  AND R3.eid = R0.eid2  AND R3.entity = R0.entity2 '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_relation_formationtemporal' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_relation_formationtemporal\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal_global/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal_global/materialize\n# {\"dependencies_\":[\"process/grounding/variable/relation_formationtemporal_global/assign_id\",\"process/grounding/variable/relation_formationtemporal/assign_id\"],\"input_\":[\"data/relation_candidates\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_relation_formationtemporal_global' as '\\n          SELECT R0.id AS \\\"relation_formationtemporal_global.R0.id\\\" , R1.id AS \\\"relation_formationtemporal.R1.id\\\" , R2.features AS \\\"dd_weight_column_0\\\" \\n          FROM relation_formationtemporal_global R0, relation_formationtemporal R1, relation_candidates R2\\n        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2 '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_relation_formationtemporal_global' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formationtemporal_global\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal_global/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_relation_formationtemporal_global' as '\n          SELECT R0.id AS \"relation_formationtemporal_global.R0.id\" , R1.id AS \"relation_formationtemporal.R1.id\" , R2.features AS \"dd_weight_column_0\" \n          FROM relation_formationtemporal_global R0, relation_formationtemporal R1, relation_candidates R2\n        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2 '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_relation_formationtemporal_global' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_relation_formationtemporal_global\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy/materialize\n# {\"dependencies_\":[\"process/grounding/variable/relation_taxonomy/assign_id\"],\"input_\":[\"data/relation_candidates\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_relation_taxonomy' as '\\n          SELECT R0.id AS \\\"relation_taxonomy.R0.id\\\" , R1.features AS \\\"dd_weight_column_0\\\" \\n          FROM relation_taxonomy R0, relation_candidates R1\\n        WHERE R1.docid = R0.docid  AND R1.type = '\\\\''TAXONOMY'\\\\'' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2 '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_relation_taxonomy' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_taxonomy\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_relation_taxonomy' as '\n          SELECT R0.id AS \"relation_taxonomy.R0.id\" , R1.features AS \"dd_weight_column_0\" \n          FROM relation_taxonomy R0, relation_candidates R1\n        WHERE R1.docid = R0.docid  AND R1.type = '\\''TAXONOMY'\\'' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2 '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_relation_taxonomy' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_relation_taxonomy\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy_global/materialize/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy_global/materialize\n# {\"dependencies_\":[\"process/grounding/variable/relation_taxonomy_global/assign_id\",\"process/grounding/variable/relation_taxonomy/assign_id\"],\"input_\":[\"data/relation_candidates\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\\n            deepdive create table 'dd_factors_inf_istrue_relation_taxonomy_global' as '\\n          SELECT R0.id AS \\\"relation_taxonomy_global.R0.id\\\" , R1.id AS \\\"relation_taxonomy.R1.id\\\" , R2.features AS \\\"dd_weight_column_0\\\" \\n          FROM relation_taxonomy_global R0, relation_taxonomy R1, relation_candidates R2\\n        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2 '\\n\\n            # find distinct weights for the factors into a separate table\\n            deepdive create table 'dd_weights_inf_istrue_relation_taxonomy_global' as 'SELECT \\\"dd_weight_column_0\\\"\\n     , false AS \\\"isfixed\\\"\\n     , 0 AS \\\"initvalue\\\"\\n     , -1 AS \\\"id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_taxonomy_global\\\"\\n\\n\\nGROUP BY \\\"dd_weight_column_0\\\"'\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy_global/materialize\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy_global/materialize'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_relation_taxonomy_global' as '\n          SELECT R0.id AS \"relation_taxonomy_global.R0.id\" , R1.id AS \"relation_taxonomy.R1.id\" , R2.features AS \"dd_weight_column_0\" \n          FROM relation_taxonomy_global R0, relation_taxonomy R1, relation_candidates R2\n        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2 '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_relation_taxonomy_global' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_relation_taxonomy_global\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        \n\n\n"
}
{
  "path": "process/grounding/weight_id_partition/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/weight_id_partition\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_formation/materialize\",\"process/grounding/factor/inf_istrue_entity_location/materialize\",\"process/grounding/factor/inf_istrue_entity_taxon/materialize\",\"process/grounding/factor/inf_istrue_entity_temporal/materialize\",\"process/grounding/factor/inf_istrue_relation_formation/materialize\",\"process/grounding/factor/inf_istrue_relation_formation_global/materialize\",\"process/grounding/factor/inf_istrue_relation_formationtemporal/materialize\",\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/materialize\",\"process/grounding/factor/inf_istrue_relation_taxonomy/materialize\",\"process/grounding/factor/inf_istrue_relation_taxonomy_global/materialize\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n        # partition the id range for weights\\n        RANGE_BEGIN=0 RANGE_STEP=1 \\\\\\n        partition_id_range 'dd_weights_inf_istrue_entity_formation' 'dd_weights_inf_istrue_entity_location' 'dd_weights_inf_istrue_entity_taxon' 'dd_weights_inf_istrue_entity_temporal' 'dd_weights_inf_istrue_relation_formation' 'dd_weights_inf_istrue_relation_formation_global' 'dd_weights_inf_istrue_relation_formationtemporal' 'dd_weights_inf_istrue_relation_formationtemporal_global' 'dd_weights_inf_istrue_relation_taxonomy' 'dd_weights_inf_istrue_relation_taxonomy_global' | {\\n            weightsCountTotal=0\\n            while read table begin excludeEnd; do\\n                factor=${table#'dd_weights_'}\\n                facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/${factor}\\n                mkdir -p \\\"$facPath\\\"\\n                cd \\\"$facPath\\\"\\n                echo $begin                      >weights_id_begin\\n                echo $excludeEnd                 >weights_id_exclude_end\\n                echo $(( $excludeEnd - $begin )) >weights_count\\n                weightsCountTotal=$excludeEnd\\n            done\\n            echo $weightsCountTotal >\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights_count\\n        }\\n        \",\"name\":\"process/grounding/weight_id_partition\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/weight_id_partition'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        # partition the id range for weights\n        RANGE_BEGIN=0 RANGE_STEP=1 \\\n        partition_id_range 'dd_weights_inf_istrue_entity_formation' 'dd_weights_inf_istrue_entity_location' 'dd_weights_inf_istrue_entity_taxon' 'dd_weights_inf_istrue_entity_temporal' 'dd_weights_inf_istrue_relation_formation' 'dd_weights_inf_istrue_relation_formation_global' 'dd_weights_inf_istrue_relation_formationtemporal' 'dd_weights_inf_istrue_relation_formationtemporal_global' 'dd_weights_inf_istrue_relation_taxonomy' 'dd_weights_inf_istrue_relation_taxonomy_global' | {\n            weightsCountTotal=0\n            while read table begin excludeEnd; do\n                factor=${table#'dd_weights_'}\n                facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/${factor}\n                mkdir -p \"$facPath\"\n                cd \"$facPath\"\n                echo $begin                      >weights_id_begin\n                echo $excludeEnd                 >weights_id_exclude_end\n                echo $(( $excludeEnd - $begin )) >weights_count\n                weightsCountTotal=$excludeEnd\n            done\n            echo $weightsCountTotal >\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights_count\n        }\n        \n\n\n"
}
{
  "path": "process/grounding/global_weight_table/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/global_weight_table\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_formation/materialize\",\"process/grounding/factor/inf_istrue_entity_location/materialize\",\"process/grounding/factor/inf_istrue_entity_taxon/materialize\",\"process/grounding/factor/inf_istrue_entity_temporal/materialize\",\"process/grounding/factor/inf_istrue_relation_formation/materialize\",\"process/grounding/factor/inf_istrue_relation_formation_global/materialize\",\"process/grounding/factor/inf_istrue_relation_formationtemporal/materialize\",\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/materialize\",\"process/grounding/factor/inf_istrue_relation_taxonomy/materialize\",\"process/grounding/factor/inf_istrue_relation_taxonomy_global/materialize\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n        # set up a union view for all weight tables (\\\"dd_graph_weights\\\")\\n        deepdive create view 'dd_graph_weights' as '(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_entity_formation-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_entity_formation\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_entity_location-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_entity_location\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_entity_taxon-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_entity_taxon\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_entity_temporal-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_entity_temporal\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_relation_formation-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_relation_formation\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_relation_formation_global-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_relation_formation_global\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_relation_formationtemporal-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_relation_formationtemporal\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_relation_formationtemporal_global-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_relation_formationtemporal_global\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_relation_taxonomy-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_relation_taxonomy\\\")\\nUNION ALL\\n(SELECT \\\"id\\\"\\n     , \\\"isfixed\\\"\\n     , \\\"initvalue\\\"\\n     , '\\\\''inf_istrue_relation_taxonomy_global-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END AS \\\"description\\\"\\n     , NULL AS \\\"categories\\\"\\nFROM \\\"dd_weights_inf_istrue_relation_taxonomy_global\\\")'\\n        \",\"name\":\"process/grounding/global_weight_table\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/global_weight_table'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        # set up a union view for all weight tables (\"dd_graph_weights\")\n        deepdive create view 'dd_graph_weights' as '(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_entity_formation-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_entity_formation\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_entity_location-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_entity_location\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_entity_taxon-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_entity_taxon\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_entity_temporal-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_entity_temporal\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_relation_formation-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_relation_formation\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_relation_formation_global-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_relation_formation_global\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_relation_formationtemporal-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_relation_formationtemporal\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_relation_formationtemporal_global-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_relation_formationtemporal_global\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_relation_taxonomy-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_relation_taxonomy\")\nUNION ALL\n(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_relation_taxonomy_global-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_relation_taxonomy_global\")'\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_formation/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_formation/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_formation'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_formation' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_formation/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_formation/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_formation'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_formation' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_location/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_location/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_location'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_location' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_location/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_location/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_location'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_location' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_taxon/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_taxon/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_taxon'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_taxon' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_taxon/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_taxon/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_taxon'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_taxon' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_temporal/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_temporal/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_temporal'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_temporal' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_temporal/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_temporal/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_temporal'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_entity_temporal' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formation'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formation' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formation'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formation' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation_global/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation_global/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formation_global'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formation_global' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation_global/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation_global/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formation_global'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formation_global' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formationtemporal'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formationtemporal' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formationtemporal'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formationtemporal' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal_global/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal_global/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formationtemporal_global'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formationtemporal_global' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal_global/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formationtemporal_global'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_formationtemporal_global' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_taxonomy'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_taxonomy' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_taxonomy'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_taxonomy' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy_global/assign_weight_id/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy_global/assign_weight_id\n# {\"dependencies_\":[\"process/grounding/weight_id_partition\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_taxonomy_global'\\n            baseId=$(cat weights_id_begin)\\n            inc=1\\n            \\n\\n            # assign weight ids according to the partition\\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_taxonomy_global' id $baseId $inc\\n\\n            \\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy_global/assign_weight_id\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy_global/assign_weight_id'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_taxonomy_global'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_relation_taxonomy_global' id $baseId $inc\n\n            \n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_formation/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_formation/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_formation/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_formation'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"entity_formation.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_formation\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_entity_formation\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_formation/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_formation/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_formation'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"entity_formation.R0.id\"\nFROM \"dd_factors_inf_istrue_entity_formation\" \"factors\", \"dd_weights_inf_istrue_entity_formation\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_location/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_location/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_location/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_location'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"entity_location.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_location\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_entity_location\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_location/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_location/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_location'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"entity_location.R0.id\"\nFROM \"dd_factors_inf_istrue_entity_location\" \"factors\", \"dd_weights_inf_istrue_entity_location\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_taxon/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_taxon/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_taxon/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_taxon'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"entity_taxon.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_taxon\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_entity_taxon\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_taxon/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_taxon/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_taxon'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"entity_taxon.R0.id\"\nFROM \"dd_factors_inf_istrue_entity_taxon\" \"factors\", \"dd_weights_inf_istrue_entity_taxon\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_temporal/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_temporal/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_temporal/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_temporal'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"entity_temporal.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_entity_temporal\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_entity_temporal\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_temporal/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_temporal/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_temporal'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"entity_temporal.R0.id\"\nFROM \"dd_factors_inf_istrue_entity_temporal\" \"factors\", \"dd_weights_inf_istrue_entity_temporal\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formation/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formation'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"relation_formation.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formation\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_relation_formation\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formation'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"relation_formation.R0.id\"\nFROM \"dd_factors_inf_istrue_relation_formation\" \"factors\", \"dd_weights_inf_istrue_relation_formation\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation_global/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation_global/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formation_global/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formation_global'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"relation_formation_global.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formation_global\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_relation_formation_global\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation_global/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation_global/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formation_global'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"relation_formation_global.R0.id\"\nFROM \"dd_factors_inf_istrue_relation_formation_global\" \"factors\", \"dd_weights_inf_istrue_relation_formation_global\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formationtemporal/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formationtemporal'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"relation_formationtemporal.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formationtemporal\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_relation_formationtemporal\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formationtemporal'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"relation_formationtemporal.R0.id\"\nFROM \"dd_factors_inf_istrue_relation_formationtemporal\" \"factors\", \"dd_weights_inf_istrue_relation_formationtemporal\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formationtemporal_global'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"relation_formationtemporal_global.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_formationtemporal_global\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_relation_formationtemporal_global\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formationtemporal_global'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"relation_formationtemporal_global.R0.id\"\nFROM \"dd_factors_inf_istrue_relation_formationtemporal_global\" \"factors\", \"dd_weights_inf_istrue_relation_formationtemporal_global\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_taxonomy/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_taxonomy'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"relation_taxonomy.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_taxonomy\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_relation_taxonomy\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_taxonomy'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"relation_taxonomy.R0.id\"\nFROM \"dd_factors_inf_istrue_relation_taxonomy\" \"factors\", \"dd_weights_inf_istrue_relation_taxonomy\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy_global/dump/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy_global/dump\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_taxonomy_global/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_taxonomy_global'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'factors.part-*.bin.bz2' \\\\\\n                    -o -name 'nfactors.part-*'         \\\\\\n                    -o -name   'nedges.part-*'         \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql='SELECT \\\"weights\\\".\\\"id\\\" AS \\\"weight_id\\\"\\n     , \\\"factors\\\".\\\"relation_taxonomy_global.R0.id\\\"\\nFROM \\\"dd_factors_inf_istrue_relation_taxonomy_global\\\" \\\"factors\\\", \\\"dd_weights_inf_istrue_relation_taxonomy_global\\\" \\\"weights\\\"\\n\\nWHERE \\\"factors\\\".\\\"dd_weight_column_0\\\" = \\\"weights\\\".\\\"dd_weight_column_0\\\"' \\\\\\n                command='\\n                    # also record the factor count\\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\\n                    # and the edge count\\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy_global/dump\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy_global/dump'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_taxonomy_global'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"relation_taxonomy_global.R0.id\"\nFROM \"dd_factors_inf_istrue_relation_taxonomy_global\" \"factors\", \"dd_weights_inf_istrue_relation_taxonomy_global\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_formation/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_formation/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_formation/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_formation'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_formation\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_entity_formation-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_formation\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_formation/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_formation/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_formation'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_formation\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_entity_formation-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_formation\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_location/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_location/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_location/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_location'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_location\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_entity_location-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_location\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_location/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_location/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_location'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_location\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_entity_location-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_location\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_taxon/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_taxon/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_taxon/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_taxon'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_taxon\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_entity_taxon-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_taxon\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_taxon/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_taxon/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_taxon'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_taxon\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_entity_taxon-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_taxon\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_entity_temporal/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_entity_temporal/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_entity_temporal/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_entity_temporal'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_temporal\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_entity_temporal-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_entity_temporal\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_entity_temporal/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_entity_temporal/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_entity_temporal'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_temporal\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_entity_temporal-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_entity_temporal\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formation/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formation'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formation\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_relation_formation-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formation\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formation'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formation\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_relation_formation-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formation\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formation_global/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formation_global/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formation_global/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formation_global'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formation_global\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_relation_formation_global-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formation_global\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formation_global/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formation_global/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formation_global'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formation_global\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_relation_formation_global-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formation_global\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formationtemporal/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formationtemporal'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formationtemporal\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_relation_formationtemporal-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formationtemporal\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formationtemporal'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formationtemporal\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_relation_formationtemporal-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formationtemporal\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_formationtemporal_global'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formationtemporal_global\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_relation_formationtemporal_global-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_formationtemporal_global\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_formationtemporal_global'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formationtemporal_global\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_relation_formationtemporal_global-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_formationtemporal_global\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_taxonomy/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_taxonomy'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_taxonomy\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_relation_taxonomy-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_taxonomy\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_taxonomy'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_taxonomy\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_relation_taxonomy-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_taxonomy\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/factor/inf_istrue_relation_taxonomy_global/dump_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/factor/inf_istrue_relation_taxonomy_global/dump_weights\n# {\"dependencies_\":[\"process/grounding/factor/inf_istrue_relation_taxonomy_global/assign_weight_id\"],\"style\":\"cmd_extractor\",\"cmd\":\"\\n            : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n            facPath=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/'inf_istrue_relation_taxonomy_global'\\n            mkdir -p \\\"$facPath\\\"\\n            cd \\\"$facPath\\\"\\n            find . \\\\( -name  'weights.part-*.bin.bz2' \\\\\\n                   \\\\) -exec rm -rf {} +\\n            export DEEPDIVE_LOAD_FORMAT=tsv\\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\\n\\n            # flag that signals whether to reuse weights or not\\n            reuseFlag=\\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/weights.reuse\\n\\n            # dump the weights (except the description column), converting into binary format for the inference engine\\n            deepdive compute execute \\\\\\n                input_sql=\\\"$(if [[ -e \\\"$reuseFlag\\\" ]]; then\\n                    echo 'SELECT \\\"w\\\".\\\"id\\\"\\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\\n     , COALESCE(reuse.weight, w.initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_taxonomy_global\\\" \\\"w\\\"\\nLEFT OUTER JOIN \\\"dd_graph_weights_reuse\\\" \\\"reuse\\\" ON \\\"reuse\\\".\\\"description\\\" = '\\\\''inf_istrue_relation_taxonomy_global-'\\\\'' ||'\\\\''-'\\\\''|| CASE WHEN \\\"dd_weight_column_0\\\" IS NULL THEN '\\\\'''\\\\''\\n              ELSE \\\"dd_weight_column_0\\\" || '\\\\'''\\\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\\n          END'\\n                else\\n                    echo 'SELECT \\\"id\\\"\\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\\n     , COALESCE(initvalue, 0)\\nFROM \\\"dd_weights_inf_istrue_relation_taxonomy_global\\\"'\\n                fi)\\\" \\\\\\n                command='\\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\\n                ' \\\\\\n                output_relation=\\n        \",\"name\":\"process/grounding/factor/inf_istrue_relation_taxonomy_global/dump_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/factor/inf_istrue_relation_taxonomy_global/dump_weights'\n\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_relation_taxonomy_global'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_taxonomy_global\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_relation_taxonomy_global-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_relation_taxonomy_global\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        \n\n\n"
}
{
  "path": "process/grounding/combine_factorgraph/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/grounding/combine_factorgraph\n# {\"dependencies_\":[\"process/grounding/variable/entity_formation/dump\",\"process/grounding/variable/entity_location/dump\",\"process/grounding/variable/entity_taxon/dump\",\"process/grounding/variable/entity_temporal/dump\",\"process/grounding/variable/relation_formation/dump\",\"process/grounding/variable/relation_formation_global/dump\",\"process/grounding/variable/relation_formationtemporal/dump\",\"process/grounding/variable/relation_formationtemporal_global/dump\",\"process/grounding/variable/relation_taxonomy/dump\",\"process/grounding/variable/relation_taxonomy_global/dump\",\"process/grounding/factor/inf_istrue_entity_formation/dump\",\"process/grounding/factor/inf_istrue_entity_formation/dump_weights\",\"process/grounding/factor/inf_istrue_entity_location/dump\",\"process/grounding/factor/inf_istrue_entity_location/dump_weights\",\"process/grounding/factor/inf_istrue_entity_taxon/dump\",\"process/grounding/factor/inf_istrue_entity_taxon/dump_weights\",\"process/grounding/factor/inf_istrue_entity_temporal/dump\",\"process/grounding/factor/inf_istrue_entity_temporal/dump_weights\",\"process/grounding/factor/inf_istrue_relation_formation/dump\",\"process/grounding/factor/inf_istrue_relation_formation/dump_weights\",\"process/grounding/factor/inf_istrue_relation_formation_global/dump\",\"process/grounding/factor/inf_istrue_relation_formation_global/dump_weights\",\"process/grounding/factor/inf_istrue_relation_formationtemporal/dump\",\"process/grounding/factor/inf_istrue_relation_formationtemporal/dump_weights\",\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump\",\"process/grounding/factor/inf_istrue_relation_formationtemporal_global/dump_weights\",\"process/grounding/factor/inf_istrue_relation_taxonomy/dump\",\"process/grounding/factor/inf_istrue_relation_taxonomy/dump_weights\",\"process/grounding/factor/inf_istrue_relation_taxonomy_global/dump\",\"process/grounding/factor/inf_istrue_relation_taxonomy_global/dump_weights\",\"process/grounding/global_weight_table\"],\"output_\":\"model/factorgraph\",\"style\":\"cmd_extractor\",\"cmd\":\"\\n        : ${DEEPDIVE_GROUNDING_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/grounding}\\n        : ${DEEPDIVE_FACTORGRAPH_DIR:=\\\"$DEEPDIVE_APP\\\"/run/model/factorgraph}\\n\\n        # create a fresh empty directory for the new combined factor graph\\n        rm -rf   \\\"$DEEPDIVE_FACTORGRAPH_DIR\\\"\\n        mkdir -p \\\"$DEEPDIVE_FACTORGRAPH_DIR\\\"\\n        cd \\\"$DEEPDIVE_FACTORGRAPH_DIR\\\"\\n\\n        # create symlinks to the grounded binaries by enumerating variables and factors\\n        for v in 'entity_formation' 'entity_location' 'entity_taxon' 'entity_temporal' 'relation_formation' 'relation_formation_global' 'relation_formationtemporal' 'relation_formationtemporal_global' 'relation_taxonomy' 'relation_taxonomy_global'; do\\n            mkdir -p variables/\\\"$v\\\"\\n            find \\\"$DEEPDIVE_GROUNDING_DIR\\\"/variable/\\\"$v\\\" \\\\\\n                -name 'variables.part-*.bin.bz2' -exec ln -sfnv -t variables/\\\"$v\\\"/ {} + \\\\\\n                #\\n        done\\n        for f in 'inf_istrue_entity_formation' 'inf_istrue_entity_location' 'inf_istrue_entity_taxon' 'inf_istrue_entity_temporal' 'inf_istrue_relation_formation' 'inf_istrue_relation_formation_global' 'inf_istrue_relation_formationtemporal' 'inf_istrue_relation_formationtemporal_global' 'inf_istrue_relation_taxonomy' 'inf_istrue_relation_taxonomy_global'; do\\n            mkdir -p {factors,weights}/\\\"$f\\\"\\n            find \\\"$DEEPDIVE_GROUNDING_DIR\\\"/factor/\\\"$f\\\" \\\\\\n                -name 'factors.part-*.bin.bz2' -exec ln -sfnv -t factors/\\\"$f\\\"/ {} + \\\\\\n                -o \\\\\\n                -name 'weights.part-*.bin.bz2' -exec ln -sfnv -t weights/\\\"$f\\\"/ {} + \\\\\\n                #\\n        done\\n\\n        # generate the metadata for the inference engine\\n        {\\n            # first line with counts of variables and edges in the grounded factor graph\\n            cd \\\"$DEEPDIVE_GROUNDING_DIR\\\"\\n            sumup() { { tr '\\\\n' +; echo 0; } | bc; }\\n            counts=()\\n            counts+=($(cat factor/weights_count))\\n            # sum up the number of factors and edges\\n            counts+=($(cat variable_count))\\n            cd factor\\n            counts+=($(find 'inf_istrue_entity_formation' 'inf_istrue_entity_location' 'inf_istrue_entity_taxon' 'inf_istrue_entity_temporal' 'inf_istrue_relation_formation' 'inf_istrue_relation_formation_global' 'inf_istrue_relation_formationtemporal' 'inf_istrue_relation_formationtemporal_global' 'inf_istrue_relation_taxonomy' 'inf_istrue_relation_taxonomy_global' -name 'nfactors.part-*' -exec cat {} + | sumup))\\n            counts+=($(find 'inf_istrue_entity_formation' 'inf_istrue_entity_location' 'inf_istrue_entity_taxon' 'inf_istrue_entity_temporal' 'inf_istrue_relation_formation' 'inf_istrue_relation_formation_global' 'inf_istrue_relation_formationtemporal' 'inf_istrue_relation_formationtemporal_global' 'inf_istrue_relation_taxonomy' 'inf_istrue_relation_taxonomy_global' -name 'nedges.part-*'   -exec cat {} + | sumup))\\n            (IFS=,; echo \\\"${counts[*]}\\\")\\n            # second line with file paths\\n            paths=(\\\"$DEEPDIVE_FACTORGRAPH_DIR\\\"/{weights,variables,factors,edges})\\n            (IFS=,; echo \\\"${paths[*]}\\\")\\n        } >meta\\n        \",\"name\":\"process/grounding/combine_factorgraph\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/grounding/combine_factorgraph'\n\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        : ${DEEPDIVE_FACTORGRAPH_DIR:=\"$DEEPDIVE_APP\"/run/model/factorgraph}\n\n        # create a fresh empty directory for the new combined factor graph\n        rm -rf   \"$DEEPDIVE_FACTORGRAPH_DIR\"\n        mkdir -p \"$DEEPDIVE_FACTORGRAPH_DIR\"\n        cd \"$DEEPDIVE_FACTORGRAPH_DIR\"\n\n        # create symlinks to the grounded binaries by enumerating variables and factors\n        for v in 'entity_formation' 'entity_location' 'entity_taxon' 'entity_temporal' 'relation_formation' 'relation_formation_global' 'relation_formationtemporal' 'relation_formationtemporal_global' 'relation_taxonomy' 'relation_taxonomy_global'; do\n            mkdir -p variables/\"$v\"\n            find \"$DEEPDIVE_GROUNDING_DIR\"/variable/\"$v\" \\\n                -name 'variables.part-*.bin.bz2' -exec ln -sfnv -t variables/\"$v\"/ {} + \\\n                #\n        done\n        for f in 'inf_istrue_entity_formation' 'inf_istrue_entity_location' 'inf_istrue_entity_taxon' 'inf_istrue_entity_temporal' 'inf_istrue_relation_formation' 'inf_istrue_relation_formation_global' 'inf_istrue_relation_formationtemporal' 'inf_istrue_relation_formationtemporal_global' 'inf_istrue_relation_taxonomy' 'inf_istrue_relation_taxonomy_global'; do\n            mkdir -p {factors,weights}/\"$f\"\n            find \"$DEEPDIVE_GROUNDING_DIR\"/factor/\"$f\" \\\n                -name 'factors.part-*.bin.bz2' -exec ln -sfnv -t factors/\"$f\"/ {} + \\\n                -o \\\n                -name 'weights.part-*.bin.bz2' -exec ln -sfnv -t weights/\"$f\"/ {} + \\\n                #\n        done\n\n        # generate the metadata for the inference engine\n        {\n            # first line with counts of variables and edges in the grounded factor graph\n            cd \"$DEEPDIVE_GROUNDING_DIR\"\n            sumup() { { tr '\\n' +; echo 0; } | bc; }\n            counts=()\n            counts+=($(cat factor/weights_count))\n            # sum up the number of factors and edges\n            counts+=($(cat variable_count))\n            cd factor\n            counts+=($(find 'inf_istrue_entity_formation' 'inf_istrue_entity_location' 'inf_istrue_entity_taxon' 'inf_istrue_entity_temporal' 'inf_istrue_relation_formation' 'inf_istrue_relation_formation_global' 'inf_istrue_relation_formationtemporal' 'inf_istrue_relation_formationtemporal_global' 'inf_istrue_relation_taxonomy' 'inf_istrue_relation_taxonomy_global' -name 'nfactors.part-*' -exec cat {} + | sumup))\n            counts+=($(find 'inf_istrue_entity_formation' 'inf_istrue_entity_location' 'inf_istrue_entity_taxon' 'inf_istrue_entity_temporal' 'inf_istrue_relation_formation' 'inf_istrue_relation_formation_global' 'inf_istrue_relation_formationtemporal' 'inf_istrue_relation_formationtemporal_global' 'inf_istrue_relation_taxonomy' 'inf_istrue_relation_taxonomy_global' -name 'nedges.part-*'   -exec cat {} + | sumup))\n            (IFS=,; echo \"${counts[*]}\")\n            # second line with file paths\n            paths=(\"$DEEPDIVE_FACTORGRAPH_DIR\"/{weights,variables,factors,edges})\n            (IFS=,; echo \"${paths[*]}\")\n        } >meta\n        \n\n\n"
}
{
  "path": "process/model/learning/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/model/learning\n# {\"dependencies_\":[\"model/factorgraph\"],\"output_\":\"model/weights\",\"style\":\"cmd_extractor\",\"cmd\":\"mkdir -p ../../../model && cd ../../../model\\n            mkdir -p weights\\n            [ -d factorgraph ] || error \\\"No factorgraph found\\\"\\n            # run inference engine for learning and inference\\n            flatten() { find -L \\\"$@\\\" -type f -exec pbzip2 -c -d -k {} +; }\\n            sampler-dw \\\\\\n                gibbs \\\\\\n                -w <(flatten factorgraph/weights) \\\\\\n                -v <(flatten factorgraph/variables) \\\\\\n                -f <(flatten factorgraph/factors) \\\\\\n                -m factorgraph/meta \\\\\\n                -o weights \\\\\\n                -l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence\\n            mkdir -p probabilities\\n            mv -f weights/inference_result.out.text probabilities/\\n        \",\"name\":\"process/model/learning\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/model/learning'\nmkdir -p ../../../model && cd ../../../model\n            mkdir -p weights\n            [ -d factorgraph ] || error \"No factorgraph found\"\n            # run inference engine for learning and inference\n            flatten() { find -L \"$@\" -type f -exec pbzip2 -c -d -k {} +; }\n            sampler-dw \\\n                gibbs \\\n                -w <(flatten factorgraph/weights) \\\n                -v <(flatten factorgraph/variables) \\\n                -f <(flatten factorgraph/factors) \\\n                -m factorgraph/meta \\\n                -o weights \\\n                -l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence\n            mkdir -p probabilities\n            mv -f weights/inference_result.out.text probabilities/\n        \n\n\n"
}
{
  "path": "process/model/inference/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/model/inference\n# {\"dependencies_\":[\"model/factorgraph\",\"model/weights\"],\"output_\":\"model/probabilities\",\"style\":\"cmd_extractor\",\"cmd\":\"mkdir -p ../../../model && cd ../../../model\\n            [ -d factorgraph ] || error \\\"No factorgraph found\\\"\\n            if [[ factorgraph/weights -nt probabilities/inference_result.out.text ]]; then\\n                # no need to run inference unless the weights are fresher\\n                # XXX this skipping may cause confusion\\n                # run sampler for performing inference with given weights without learning\\n                flatten() { find -L \\\"$@\\\" -type f -exec pbzip2 -c -d -k {} +; }\\n                sampler-dw \\\\\\n                    gibbs \\\\\\n                    -w <(flatten factorgraph/weights) \\\\\\n                    -v <(flatten factorgraph/variables) \\\\\\n                    -f <(flatten factorgraph/factors) \\\\\\n                    -m factorgraph/meta \\\\\\n                    -o weights \\\\\\n                    -l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence \\\\\\n                    -l 0 \\\\\\n                    #\\n                mkdir -p probabilities\\n                mv -f weights/inference_result.out.text probabilities/\\n            fi\\n        \",\"name\":\"process/model/inference\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/model/inference'\nmkdir -p ../../../model && cd ../../../model\n            [ -d factorgraph ] || error \"No factorgraph found\"\n            if [[ factorgraph/weights -nt probabilities/inference_result.out.text ]]; then\n                # no need to run inference unless the weights are fresher\n                # XXX this skipping may cause confusion\n                # run sampler for performing inference with given weights without learning\n                flatten() { find -L \"$@\" -type f -exec pbzip2 -c -d -k {} +; }\n                sampler-dw \\\n                    gibbs \\\n                    -w <(flatten factorgraph/weights) \\\n                    -v <(flatten factorgraph/variables) \\\n                    -f <(flatten factorgraph/factors) \\\n                    -m factorgraph/meta \\\n                    -o weights \\\n                    -l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence \\\n                    -l 0 \\\n                    #\n                mkdir -p probabilities\n                mv -f weights/inference_result.out.text probabilities/\n            fi\n        \n\n\n"
}
{
  "path": "process/model/load_weights/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/model/load_weights\n# {\"dependencies_\":[\"model/weights\"],\"output_\":\"data/model/weights\",\"style\":\"cmd_extractor\",\"cmd\":\"mkdir -p ../../../model && cd ../../../model\\n            # load weights to database\\n            deepdive create table dd_inference_result_weights \\\\\\n                id:BIGINT:'PRIMARY KEY' \\\\\\n                weight:'DOUBLE PRECISION' \\\\\\n                #\\n            cat weights/inference_result.out.weights.text |\\n            tr ' ' '\\\\t' | DEEPDIVE_LOAD_FORMAT=tsv \\\\\\n            deepdive load dd_inference_result_weights /dev/stdin\\n\\n            # create views\\n            deepdive create view dd_inference_result_weights_mapping as '\\n                SELECT dd_graph_weights.*, dd_inference_result_weights.weight FROM\\n                dd_graph_weights JOIN dd_inference_result_weights ON dd_graph_weights.id = dd_inference_result_weights.id\\n                ORDER BY abs(weight) DESC\\n            '\\n\\n            deepdive create view dd_inference_result_variables_mapped_weights as '\\n                SELECT * FROM dd_inference_result_weights_mapping\\n                ORDER BY abs(weight) DESC\\n            '\\n        \",\"name\":\"process/model/load_weights\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/model/load_weights'\nmkdir -p ../../../model && cd ../../../model\n            # load weights to database\n            deepdive create table dd_inference_result_weights \\\n                id:BIGINT:'PRIMARY KEY' \\\n                weight:'DOUBLE PRECISION' \\\n                #\n            cat weights/inference_result.out.weights.text |\n            tr ' ' '\\t' | DEEPDIVE_LOAD_FORMAT=tsv \\\n            deepdive load dd_inference_result_weights /dev/stdin\n\n            # create views\n            deepdive create view dd_inference_result_weights_mapping as '\n                SELECT dd_graph_weights.*, dd_inference_result_weights.weight FROM\n                dd_graph_weights JOIN dd_inference_result_weights ON dd_graph_weights.id = dd_inference_result_weights.id\n                ORDER BY abs(weight) DESC\n            '\n\n            deepdive create view dd_inference_result_variables_mapped_weights as '\n                SELECT * FROM dd_inference_result_weights_mapping\n                ORDER BY abs(weight) DESC\n            '\n        \n\n\n"
}
{
  "path": "process/model/load_probabilities/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/model/load_probabilities\n# {\"dependencies_\":[\"model/probabilities\"],\"output_\":\"data/model/probabilities\",\"style\":\"cmd_extractor\",\"cmd\":\"mkdir -p ../../../model && cd ../../../model\\n            # load weights to database\\n            deepdive create table dd_inference_result_variables \\\\\\n                id:BIGINT \\\\\\n                category:BIGINT \\\\\\n                expectation:'DOUBLE PRECISION' \\\\\\n                #\\n            cat probabilities/inference_result.out.text |\\n            tr ' ' '\\\\t' | DEEPDIVE_LOAD_FORMAT=tsv \\\\\\n            deepdive load dd_inference_result_variables /dev/stdin\\n\\n            # create a view for each app schema variable\\n            \\n            deepdive create view 'entity_formation_label_inference' as '\\n                SELECT entity_formation.*, mir.category, mir.expectation FROM\\n                entity_formation, dd_inference_result_variables mir\\n                WHERE entity_formation.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'entity_location_label_inference' as '\\n                SELECT entity_location.*, mir.category, mir.expectation FROM\\n                entity_location, dd_inference_result_variables mir\\n                WHERE entity_location.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'entity_taxon_label_inference' as '\\n                SELECT entity_taxon.*, mir.category, mir.expectation FROM\\n                entity_taxon, dd_inference_result_variables mir\\n                WHERE entity_taxon.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'entity_temporal_label_inference' as '\\n                SELECT entity_temporal.*, mir.category, mir.expectation FROM\\n                entity_temporal, dd_inference_result_variables mir\\n                WHERE entity_temporal.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'relation_formation_label_inference' as '\\n                SELECT relation_formation.*, mir.category, mir.expectation FROM\\n                relation_formation, dd_inference_result_variables mir\\n                WHERE relation_formation.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'relation_formation_global_label_inference' as '\\n                SELECT relation_formation_global.*, mir.category, mir.expectation FROM\\n                relation_formation_global, dd_inference_result_variables mir\\n                WHERE relation_formation_global.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'relation_formationtemporal_label_inference' as '\\n                SELECT relation_formationtemporal.*, mir.category, mir.expectation FROM\\n                relation_formationtemporal, dd_inference_result_variables mir\\n                WHERE relation_formationtemporal.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'relation_formationtemporal_global_label_inference' as '\\n                SELECT relation_formationtemporal_global.*, mir.category, mir.expectation FROM\\n                relation_formationtemporal_global, dd_inference_result_variables mir\\n                WHERE relation_formationtemporal_global.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'relation_taxonomy_label_inference' as '\\n                SELECT relation_taxonomy.*, mir.category, mir.expectation FROM\\n                relation_taxonomy, dd_inference_result_variables mir\\n                WHERE relation_taxonomy.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n\\n            deepdive create view 'relation_taxonomy_global_label_inference' as '\\n                SELECT relation_taxonomy_global.*, mir.category, mir.expectation FROM\\n                relation_taxonomy_global, dd_inference_result_variables mir\\n                WHERE relation_taxonomy_global.id = mir.id\\n                ORDER BY mir.expectation DESC\\n                '\\n        \",\"name\":\"process/model/load_probabilities\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/model/load_probabilities'\nmkdir -p ../../../model && cd ../../../model\n            # load weights to database\n            deepdive create table dd_inference_result_variables \\\n                id:BIGINT \\\n                category:BIGINT \\\n                expectation:'DOUBLE PRECISION' \\\n                #\n            cat probabilities/inference_result.out.text |\n            tr ' ' '\\t' | DEEPDIVE_LOAD_FORMAT=tsv \\\n            deepdive load dd_inference_result_variables /dev/stdin\n\n            # create a view for each app schema variable\n            \n            deepdive create view 'entity_formation_label_inference' as '\n                SELECT entity_formation.*, mir.category, mir.expectation FROM\n                entity_formation, dd_inference_result_variables mir\n                WHERE entity_formation.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'entity_location_label_inference' as '\n                SELECT entity_location.*, mir.category, mir.expectation FROM\n                entity_location, dd_inference_result_variables mir\n                WHERE entity_location.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'entity_taxon_label_inference' as '\n                SELECT entity_taxon.*, mir.category, mir.expectation FROM\n                entity_taxon, dd_inference_result_variables mir\n                WHERE entity_taxon.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'entity_temporal_label_inference' as '\n                SELECT entity_temporal.*, mir.category, mir.expectation FROM\n                entity_temporal, dd_inference_result_variables mir\n                WHERE entity_temporal.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'relation_formation_label_inference' as '\n                SELECT relation_formation.*, mir.category, mir.expectation FROM\n                relation_formation, dd_inference_result_variables mir\n                WHERE relation_formation.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'relation_formation_global_label_inference' as '\n                SELECT relation_formation_global.*, mir.category, mir.expectation FROM\n                relation_formation_global, dd_inference_result_variables mir\n                WHERE relation_formation_global.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'relation_formationtemporal_label_inference' as '\n                SELECT relation_formationtemporal.*, mir.category, mir.expectation FROM\n                relation_formationtemporal, dd_inference_result_variables mir\n                WHERE relation_formationtemporal.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'relation_formationtemporal_global_label_inference' as '\n                SELECT relation_formationtemporal_global.*, mir.category, mir.expectation FROM\n                relation_formationtemporal_global, dd_inference_result_variables mir\n                WHERE relation_formationtemporal_global.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'relation_taxonomy_label_inference' as '\n                SELECT relation_taxonomy.*, mir.category, mir.expectation FROM\n                relation_taxonomy, dd_inference_result_variables mir\n                WHERE relation_taxonomy.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n\n            deepdive create view 'relation_taxonomy_global_label_inference' as '\n                SELECT relation_taxonomy_global.*, mir.category, mir.expectation FROM\n                relation_taxonomy_global, dd_inference_result_variables mir\n                WHERE relation_taxonomy_global.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n        \n\n\n"
}
{
  "path": "process/model/calibration/run.sh",
  "mode": "+x",
  "content": "#!/usr/bin/env bash\n# cmd_extractor  process/model/calibration\n# {\"dependencies_\":[\"data/model/probabilities\",\"process/model/load_probabilities\"],\"output_\":\"model/calibration-plots\",\"style\":\"cmd_extractor\",\"cmd\":\"\\n            d=../../../model/calibration-plots && mkdir -p \\\"$d\\\" && cd \\\"$d\\\"\\n            # XXX a legacy location under the current run directory for backward compatibility\\n            extraOutput=\\\"${DEEPDIVE_OUTPUT:-../../RUNNING}\\\"/calibration && mkdir -p \\\"$extraOutput\\\"\\n            DEEPDIVE_CALIBRATION_NUM_BUCKETS=10\\n            \\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'entity_formation' 'label'\\n            draw_calibration_plot      'entity_formation' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'entity_formation_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'entity_location' 'label'\\n            draw_calibration_plot      'entity_location' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'entity_location_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'entity_taxon' 'label'\\n            draw_calibration_plot      'entity_taxon' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'entity_taxon_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'entity_temporal' 'label'\\n            draw_calibration_plot      'entity_temporal' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'entity_temporal_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'relation_formation' 'label'\\n            draw_calibration_plot      'relation_formation' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'relation_formation_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'relation_formation_global' 'label'\\n            draw_calibration_plot      'relation_formation_global' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'relation_formation_global_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'relation_formationtemporal' 'label'\\n            draw_calibration_plot      'relation_formationtemporal' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'relation_formationtemporal_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'relation_formationtemporal_global' 'label'\\n            draw_calibration_plot      'relation_formationtemporal_global' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'relation_formationtemporal_global_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'relation_taxonomy' 'label'\\n            draw_calibration_plot      'relation_taxonomy' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'relation_taxonomy_label'.* \\\"$extraOutput\\\"/\\n            \\n\\n            # create a view and draw a calibration plot for variable null\\n            deepdive db create_calibration_view 'relation_taxonomy_global' 'label'\\n            draw_calibration_plot      'relation_taxonomy_global' 'label'\\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\\n            cp -a 'relation_taxonomy_global_label'.* \\\"$extraOutput\\\"/\\n            \\n        \",\"name\":\"process/model/calibration\"}\nset -xeuo pipefail\ncd \"$(dirname \"$0\")\"\n\n\n\nexport DEEPDIVE_CURRENT_PROCESS_NAME='process/model/calibration'\n\n            d=../../../model/calibration-plots && mkdir -p \"$d\" && cd \"$d\"\n            # XXX a legacy location under the current run directory for backward compatibility\n            extraOutput=\"${DEEPDIVE_OUTPUT:-../../RUNNING}\"/calibration && mkdir -p \"$extraOutput\"\n            DEEPDIVE_CALIBRATION_NUM_BUCKETS=10\n            \n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'entity_formation' 'label'\n            draw_calibration_plot      'entity_formation' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'entity_formation_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'entity_location' 'label'\n            draw_calibration_plot      'entity_location' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'entity_location_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'entity_taxon' 'label'\n            draw_calibration_plot      'entity_taxon' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'entity_taxon_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'entity_temporal' 'label'\n            draw_calibration_plot      'entity_temporal' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'entity_temporal_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'relation_formation' 'label'\n            draw_calibration_plot      'relation_formation' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'relation_formation_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'relation_formation_global' 'label'\n            draw_calibration_plot      'relation_formation_global' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'relation_formation_global_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'relation_formationtemporal' 'label'\n            draw_calibration_plot      'relation_formationtemporal' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'relation_formationtemporal_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'relation_formationtemporal_global' 'label'\n            draw_calibration_plot      'relation_formationtemporal_global' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'relation_formationtemporal_global_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'relation_taxonomy' 'label'\n            draw_calibration_plot      'relation_taxonomy' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'relation_taxonomy_label'.* \"$extraOutput\"/\n            \n\n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'relation_taxonomy_global' 'label'\n            draw_calibration_plot      'relation_taxonomy_global' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'relation_taxonomy_global_label'.* \"$extraOutput\"/\n            \n        \n\n\n"
}
