
  deepdive.db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
    incremental_mode: ORIGINAL
    }
    


      deepdive.schema.variables {
        relation_formationlocation.label: Boolean
relation_taxonomy.label: Boolean
entity_formation.label: Boolean
relation_formationlocation_global.label: Boolean
relation_formation.label: Boolean
entity_location.label: Boolean
entity_temporal.label: Boolean
relation_taxonomy_global.label: Boolean
entity_taxon.label: Boolean
relation_formation_global.label: Boolean
relation_formationtemporal_global.label: Boolean
relation_formationtemporal.label: Boolean
      }
    

          deepdive.extraction.extractors.extraction_rule_12 {
            sql: """ DROP TABLE IF EXISTS formation_per_doc CASCADE;
            CREATE TABLE
            formation_per_doc(docid text,
                 entity text[],
                 type text[])
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_0 {
            sql: """ DROP TABLE IF EXISTS sentences CASCADE;
            CREATE TABLE
            sentences(docid text,
         sentid text,
         wordindex text[],
         words text[],
         poses text[],
         ners text[],
         lemmas text[],
         dep_paths text[],
         dep_parents text[],
         font text[],
         layout text[])
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_25 {
            sql: """ DROP TABLE IF EXISTS relation_formationlocation CASCADE;
            CREATE TABLE
            relation_formationlocation(docid text,
                          type text,
                          eid1 text,
                          eid2 text,
                          entity1 text,
                          entity2 text,
                          id bigint,
                          label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_18 {
            sql: """ DROP TABLE IF EXISTS relation_candidates CASCADE;
            CREATE TABLE
            relation_candidates(docid text,
                   type text,
                   eid1 text,
                   eid2 text,
                   entity1 text,
                   entity2 text,
                   features text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_5 {
            sql: """ DROP TABLE IF EXISTS entity_formation_candidate_local CASCADE;
            CREATE TABLE
            entity_formation_candidate_local(docid text,
                                type text,
                                eid text,
                                entity text,
                                prov text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_14 {
            sql: """ DROP TABLE IF EXISTS all_entity_per_doc CASCADE;
            CREATE TABLE
            all_entity_per_doc(docid text,
                  eid text[],
                  entity text[],
                  type text[],
                  prov text[])
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_29 {
            sql: """ DROP TABLE IF EXISTS relation_formationlocation_supervise CASCADE;
            CREATE TABLE
            relation_formationlocation_supervise(docid text,
                                    type text,
                                    eid1 text,
                                    eid2 text,
                                    entity1 text,
                                    entity2 text,
                                    label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_1 {
            sql: """ DROP TABLE IF EXISTS ddtables CASCADE;
            CREATE TABLE
            ddtables(docid text,
        tableid text,
        type text,
        sentid text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_6 {
            sql: """ DROP TABLE IF EXISTS entity_taxon_candidate_local CASCADE;
            CREATE TABLE
            entity_taxon_candidate_local(docid text,
                            type text,
                            eid text,
                            entity text,
                            author_year text,
                            prov text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_4 {
            sql: """ DROP TABLE IF EXISTS documents_serialized CASCADE;
            CREATE TABLE
            documents_serialized(docid text,
                    sentids text,
                    wordidxs text,
                    words text,
                    poses text,
                    ners text,
                    lemmas text,
                    dep_paths text,
                    dep_parents text,
                    font text,
                    layout text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_32 {
            sql: """ DROP TABLE IF EXISTS relation_formationtemporal_global CASCADE;
            CREATE TABLE
            relation_formationtemporal_global(type text,
                                 entity1 text,
                                 entity2 text,
                                 id bigint,
                                 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_16 {
            sql: """ DROP TABLE IF EXISTS document_with_taxon_entities CASCADE;
            CREATE TABLE
            document_with_taxon_entities(docid text,
                            entities text,
                            types text,
                            sentids text,
                            wordidxs text,
                            words text,
                            poses text,
                            ners text,
                            lemmas text,
                            dep_paths text,
                            dep_parents text,
                            font text,
                            layout text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_35 {
            sql: """ DROP TABLE IF EXISTS interval_containments CASCADE;
            CREATE TABLE
            interval_containments(formation text,
                     child text,
                     parent text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_24 {
            sql: """ DROP TABLE IF EXISTS relation_formationtemporal CASCADE;
            CREATE TABLE
            relation_formationtemporal(docid text,
                          type text,
                          eid1 text,
                          eid2 text,
                          entity1 text,
                          entity2 text,
                          id bigint,
                          label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_21 {
            sql: """ DROP TABLE IF EXISTS entity_location CASCADE;
            CREATE TABLE
            entity_location(docid text,
               type text,
               eid text,
               entity text,
               prov text,
               id bigint,
               label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_31 {
            sql: """ DROP TABLE IF EXISTS relation_formation_global CASCADE;
            CREATE TABLE
            relation_formation_global(type text,
                         entity1 text,
                         entity2 text,
                         id bigint,
                         label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_33 {
            sql: """ DROP TABLE IF EXISTS relation_formationlocation_global CASCADE;
            CREATE TABLE
            relation_formationlocation_global(type text,
                                 entity1 text,
                                 entity2 text,
                                 id bigint,
                                 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_27 {
            sql: """ DROP TABLE IF EXISTS relation_formation_supervise CASCADE;
            CREATE TABLE
            relation_formation_supervise(docid text,
                            type text,
                            eid1 text,
                            eid2 text,
                            entity1 text,
                            entity2 text,
                            label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_3 {
            sql: """ DROP TABLE IF EXISTS documents CASCADE;
            CREATE TABLE
            documents(docid text,
         sentids text[],
         wordidxs text[],
         words text[],
         poses text[],
         ners text[],
         lemmas text[],
         dep_paths text[],
         dep_parents text[],
         font text[],
         layout text[])
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_30 {
            sql: """ DROP TABLE IF EXISTS relation_taxonomy_supervise CASCADE;
            CREATE TABLE
            relation_taxonomy_supervise(docid text,
                           type text,
                           eid1 text,
                           eid2 text,
                           entity1 text,
                           entity2 text,
                           label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_11 {
            sql: """ DROP TABLE IF EXISTS all_entity_candidate CASCADE;
            CREATE TABLE
            all_entity_candidate(docid text,
                    type text,
                    eid text,
                    entity text,
                    prov text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_7 {
            sql: """ DROP TABLE IF EXISTS entity_formation_candidate CASCADE;
            CREATE TABLE
            entity_formation_candidate(docid text,
                          type text,
                          eid text,
                          entity text,
                          prov text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_15 {
            sql: """ DROP TABLE IF EXISTS document_with_formation_entities CASCADE;
            CREATE TABLE
            document_with_formation_entities(docid text,
                                entities text,
                                types text,
                                sentids text,
                                wordidxs text,
                                words text,
                                poses text,
                                ners text,
                                lemmas text,
                                dep_paths text,
                                dep_parents text,
                                font text,
                                layout text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_22 {
            sql: """ DROP TABLE IF EXISTS entity_temporal CASCADE;
            CREATE TABLE
            entity_temporal(docid text,
               type text,
               eid text,
               entity text,
               prov text,
               id bigint,
               label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_23 {
            sql: """ DROP TABLE IF EXISTS relation_formation CASCADE;
            CREATE TABLE
            relation_formation(docid text,
                  type text,
                  eid1 text,
                  eid2 text,
                  entity1 text,
                  entity2 text,
                  id bigint,
                  label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_10 {
            sql: """ DROP TABLE IF EXISTS entity_temporal_candidate CASCADE;
            CREATE TABLE
            entity_temporal_candidate(docid text,
                         type text,
                         eid text,
                         entity text,
                         prov text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_20 {
            sql: """ DROP TABLE IF EXISTS entity_taxon CASCADE;
            CREATE TABLE
            entity_taxon(docid text,
            type text,
            eid text,
            entity text,
            author_year text,
            prov text,
            id bigint,
            label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_26 {
            sql: """ DROP TABLE IF EXISTS relation_taxonomy CASCADE;
            CREATE TABLE
            relation_taxonomy(docid text,
                 type text,
                 eid1 text,
                 eid2 text,
                 entity1 text,
                 entity2 text,
                 id bigint,
                 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_2 {
            sql: """ DROP TABLE IF EXISTS sentences_serialized CASCADE;
            CREATE TABLE
            sentences_serialized(docid text,
                    sentid text,
                    wordidxs text,
                    words text,
                    poses text,
                    ners text,
                    lemmas text,
                    dep_paths text,
                    dep_parents text,
                    font text,
                    layout text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_34 {
            sql: """ DROP TABLE IF EXISTS relation_taxonomy_global CASCADE;
            CREATE TABLE
            relation_taxonomy_global(type text,
                        entity1 text,
                        entity2 text,
                        id bigint,
                        label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_13 {
            sql: """ DROP TABLE IF EXISTS taxon_per_doc CASCADE;
            CREATE TABLE
            taxon_per_doc(docid text,
             entity text[],
             type text[])
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_36 {
            sql: """ DROP TABLE IF EXISTS interval_not_that_possible CASCADE;
            CREATE TABLE
            interval_not_that_possible(formation text,
                          interval1 text,
                          interval2 text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_28 {
            sql: """ DROP TABLE IF EXISTS relation_formationtemporal_supervise CASCADE;
            CREATE TABLE
            relation_formationtemporal_supervise(docid text,
                                    type text,
                                    eid1 text,
                                    eid2 text,
                                    entity1 text,
                                    entity2 text,
                                    label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_17 {
            sql: """ DROP TABLE IF EXISTS document_with_all_entities CASCADE;
            CREATE TABLE
            document_with_all_entities(docid text,
                          entities text,
                          types text,
                          eids text,
                          provs text,
                          sentids text,
                          wordidxs text,
                          words text,
                          poses text,
                          ners text,
                          lemmas text,
                          dep_paths text,
                          dep_parents text,
                          font text,
                          layout text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_19 {
            sql: """ DROP TABLE IF EXISTS entity_formation CASCADE;
            CREATE TABLE
            entity_formation(docid text,
                type text,
                eid text,
                entity text,
                prov text,
                id bigint,
                label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_8 {
            sql: """ DROP TABLE IF EXISTS entity_taxon_candidate CASCADE;
            CREATE TABLE
            entity_taxon_candidate(docid text,
                      type text,
                      eid text,
                      entity text,
                      author_year text,
                      prov text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_9 {
            sql: """ DROP TABLE IF EXISTS entity_location_candidate CASCADE;
            CREATE TABLE
            entity_location_candidate(docid text,
                         type text,
                         eid text,
                         entity text,
                         prov text)
            """
            style: "sql_extractor"
          }

        deepdive.extraction.extractors.cleanup {
          sql: """
          TRUNCATE formation_per_doc;
          TRUNCATE sentences;
          TRUNCATE relation_formationlocation;
          TRUNCATE relation_candidates;
          TRUNCATE entity_formation_candidate_local;
          TRUNCATE all_entity_per_doc;
          TRUNCATE relation_formationlocation_supervise;
          TRUNCATE ddtables;
          TRUNCATE entity_taxon_candidate_local;
          TRUNCATE documents_serialized;
          TRUNCATE relation_formationtemporal_global;
          TRUNCATE document_with_taxon_entities;
          TRUNCATE interval_containments;
          TRUNCATE relation_formationtemporal;
          TRUNCATE entity_location;
          TRUNCATE relation_formation_global;
          TRUNCATE relation_formationlocation_global;
          TRUNCATE relation_formation_supervise;
          TRUNCATE documents;
          TRUNCATE relation_taxonomy_supervise;
          TRUNCATE all_entity_candidate;
          TRUNCATE entity_formation_candidate;
          TRUNCATE document_with_formation_entities;
          TRUNCATE entity_temporal;
          TRUNCATE relation_formation;
          TRUNCATE entity_temporal_candidate;
          TRUNCATE entity_taxon;
          TRUNCATE relation_taxonomy;
          TRUNCATE sentences_serialized;
          TRUNCATE relation_taxonomy_global;
          TRUNCATE taxon_per_doc;
          TRUNCATE interval_not_that_possible;
          TRUNCATE relation_formationtemporal_supervise;
          TRUNCATE document_with_all_entities;
          TRUNCATE entity_formation;
          TRUNCATE entity_taxon_candidate;
          TRUNCATE entity_location_candidate;
          """
          style: "sql_extractor"
        }

      deepdive.extraction.extractors.extraction_rule_46 {
        sql: """ 
        INSERT INTO formation_per_doc 
            SELECT  R0.docid AS "entity_formation_candidate_local.R0.docid" , ARRAY_AGG(R0.entity) AS "ARRAY_AGG_R0.entity", ARRAY_AGG(R0.type) AS "ARRAY_AGG_R0.type"
            FROM entity_formation_candidate_local R0
        
        GROUP BY R0.docid
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_41" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_77 {
        sql: """ 
        INSERT INTO relation_formationlocation SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 as id, R0.label AS label
          FROM relation_formationlocation_supervise R0
        
          
        """
        style: "sql_extractor"
          
      }
    

      deepdive.extraction.extractors.extraction_rule_62 {
        sql: """ 
        INSERT INTO all_entity_per_doc 
            SELECT  R0.docid AS "all_entity_candidate.R0.docid" , ARRAY_AGG(R0.eid) AS "ARRAY_AGG_R0.eid", ARRAY_AGG(R0.entity) AS "ARRAY_AGG_R0.entity", ARRAY_AGG(R0.type) AS "ARRAY_AGG_R0.type", ARRAY_AGG(R0.prov) AS "ARRAY_AGG_R0.prov"
            FROM all_entity_candidate R0
        
        GROUP BY R0.docid
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_58" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_39 {
        sql: """ 
        INSERT INTO documents_serialized 
            SELECT  R0.docid AS "documents.R0.docid" , array_to_string(R0.sentids, '|||||'), array_to_string(R0.wordidxs, '|||||'), array_to_string(R0.words, '|||||'), array_to_string(R0.poses, '|||||'), array_to_string(R0.ners, '|||||'), array_to_string(R0.lemmas, '|||||'), array_to_string(R0.dep_paths, '|||||'), array_to_string(R0.dep_parents, '|||||'), array_to_string(R0.font, '|||||'), array_to_string(R0.layout, '|||||')
            FROM documents R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_38" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_83 {
        sql: """ 
        INSERT INTO relation_formationtemporal_global 
            SELECT DISTINCT R0.type AS "relation_formationtemporal.R0.type" , R0.eid1 AS "relation_formationtemporal.R0.eid1" , R0.eid2 AS "relation_formationtemporal.R0.eid2" 
            FROM relation_formationtemporal R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_76" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_53 {
        sql: """ 
        INSERT INTO document_with_taxon_entities 
            SELECT  R0.docid AS "taxon_per_doc.R0.docid" , array_to_string(R0.entity, '@@@@@'), array_to_string(R0.type, '@@@@@'), R1.sentids AS "documents_serialized.R1.sentids" , R1.wordidxs AS "documents_serialized.R1.wordidxs" , R1.words AS "documents_serialized.R1.words" , R1.poses AS "documents_serialized.R1.poses" , R1.ners AS "documents_serialized.R1.ners" , R1.lemmas AS "documents_serialized.R1.lemmas" , R1.dep_paths AS "documents_serialized.R1.dep_paths" , R1.dep_parents AS "documents_serialized.R1.dep_parents" , R1.font AS "documents_serialized.R1.font" , R1.layout AS "documents_serialized.R1.layout" 
            FROM taxon_per_doc R0, documents_serialized R1
        WHERE R1.docid = R0.docid  
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_47" ,  "extraction_rule_39" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_76 {
        sql: """ 
        INSERT INTO relation_formationtemporal SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 as id, R0.label AS label
          FROM relation_formationtemporal_supervise R0
        
          
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_69" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_92 {
        sql: """ 
        INSERT INTO entity_location 
            SELECT  R0.docid AS "entity_location_candidate.R0.docid" , R0.type AS "entity_location_candidate.R0.type" , R0.eid AS "entity_location_candidate.R0.eid" , R0.entity AS "entity_location_candidate.R0.entity" , R0.prov AS "entity_location_candidate.R0.prov" 
            FROM entity_location_candidate R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_57" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_82 {
        sql: """ 
        INSERT INTO relation_formation_global 
            SELECT DISTINCT R0.type AS "relation_formation.R0.type" , R0.eid1 AS "relation_formation.R0.eid1" , R0.eid2 AS "relation_formation.R0.eid2" 
            FROM relation_formation R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_74" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_84 {
        sql: """ 
        INSERT INTO relation_formationlocation_global 
            SELECT DISTINCT R0.type AS "relation_formationlocation.R0.type" , R0.eid1 AS "relation_formationlocation.R0.eid1" , R0.eid2 AS "relation_formationlocation.R0.eid2" 
            FROM relation_formationlocation R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_77" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_38 {
        sql: """ 
        INSERT INTO documents 
            SELECT DISTINCT R0.docid AS "sentences_serialized.R0.docid" , ARRAY_AGG(R0.sentid) AS "ARRAY_AGG_R0.sentid", ARRAY_AGG(R0.wordidxs) AS "ARRAY_AGG_R0.wordidxs", ARRAY_AGG(R0.words) AS "ARRAY_AGG_R0.words", ARRAY_AGG(R0.poses) AS "ARRAY_AGG_R0.poses", ARRAY_AGG(R0.ners) AS "ARRAY_AGG_R0.ners", ARRAY_AGG(R0.lemmas) AS "ARRAY_AGG_R0.lemmas", ARRAY_AGG(R0.dep_paths) AS "ARRAY_AGG_R0.dep_paths", ARRAY_AGG(R0.dep_parents) AS "ARRAY_AGG_R0.dep_parents", ARRAY_AGG(R0.font) AS "ARRAY_AGG_R0.font", ARRAY_AGG(R0.layout) AS "ARRAY_AGG_R0.layout"
            FROM sentences_serialized R0
        
        GROUP BY R0.docid
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_37" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_58 {
        sql: """ 
        INSERT INTO all_entity_candidate 
            SELECT  R0.docid AS "entity_formation_candidate.R0.docid" , 'FORMATION', R0.eid AS "entity_formation_candidate.R0.eid" , R0.entity AS "entity_formation_candidate.R0.entity" , R0.prov AS "entity_formation_candidate.R0.prov" 
            FROM entity_formation_candidate R0
         UNION ALL 
            SELECT  R0.docid AS "entity_temporal_candidate.R0.docid" , 'INTERVAL', R0.eid AS "entity_temporal_candidate.R0.eid" , R0.entity AS "entity_temporal_candidate.R0.entity" , R0.prov AS "entity_temporal_candidate.R0.prov" 
            FROM entity_temporal_candidate R0
         UNION ALL 
            SELECT  R0.docid AS "entity_taxon_candidate.R0.docid" , 'TAXON-' || R0.type, R0.eid AS "entity_taxon_candidate.R0.eid" , R0.entity AS "entity_taxon_candidate.R0.entity" , R0.prov AS "entity_taxon_candidate.R0.prov" 
            FROM entity_taxon_candidate R0
         UNION ALL 
            SELECT  R0.docid AS "entity_location_candidate.R0.docid" , 'LOCATION', R0.eid AS "entity_location_candidate.R0.eid" , R0.entity AS "entity_location_candidate.R0.entity" , R0.prov AS "entity_location_candidate.R0.prov" 
            FROM entity_location_candidate R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_54" ,  "extraction_rule_51" ,  "extraction_rule_55" ,  "extraction_rule_50" ,  "extraction_rule_43" ,  "extraction_rule_57" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_51 {
        sql: """ 
        INSERT INTO entity_formation_candidate 
            SELECT  R0.docid AS "entity_formation_candidate_local.R0.docid" , R0.type AS "entity_formation_candidate_local.R0.type" , R0.eid AS "entity_formation_candidate_local.R0.eid" , R0.entity AS "entity_formation_candidate_local.R0.entity" , R0.prov AS "entity_formation_candidate_local.R0.prov" 
            FROM entity_formation_candidate_local R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_41" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_49 {
        sql: """ 
        INSERT INTO document_with_formation_entities 
            SELECT  R0.docid AS "formation_per_doc.R0.docid" , array_to_string(R0.entity, '@@@@@'), array_to_string(R0.type, '@@@@@'), R1.sentids AS "documents_serialized.R1.sentids" , R1.wordidxs AS "documents_serialized.R1.wordidxs" , R1.words AS "documents_serialized.R1.words" , R1.poses AS "documents_serialized.R1.poses" , R1.ners AS "documents_serialized.R1.ners" , R1.lemmas AS "documents_serialized.R1.lemmas" , R1.dep_paths AS "documents_serialized.R1.dep_paths" , R1.dep_parents AS "documents_serialized.R1.dep_parents" , R1.font AS "documents_serialized.R1.font" , R1.layout AS "documents_serialized.R1.layout" 
            FROM formation_per_doc R0, documents_serialized R1
        WHERE R1.docid = R0.docid  
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_46" ,  "extraction_rule_39" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_91 {
        sql: """ 
        INSERT INTO entity_temporal 
            SELECT  R0.docid AS "entity_temporal_candidate.R0.docid" , R0.type AS "entity_temporal_candidate.R0.type" , R0.eid AS "entity_temporal_candidate.R0.eid" , R0.entity AS "entity_temporal_candidate.R0.entity" , R0.prov AS "entity_temporal_candidate.R0.prov" 
            FROM entity_temporal_candidate R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_43" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_74 {
        sql: """ 
        INSERT INTO relation_formation SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 as id, R0.label AS label
          FROM relation_formation_supervise R0
        
          
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_73" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_93 {
        sql: """ 
        INSERT INTO entity_taxon 
            SELECT  R0.docid AS "entity_taxon_candidate.R0.docid" , R0.type AS "entity_taxon_candidate.R0.type" , R0.eid AS "entity_taxon_candidate.R0.eid" , R0.entity AS "entity_taxon_candidate.R0.entity" , R0.author_year AS "entity_taxon_candidate.R0.author_year" , R0.prov AS "entity_taxon_candidate.R0.prov" 
            FROM entity_taxon_candidate R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_55" ,  "extraction_rule_54" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_75 {
        sql: """ 
        INSERT INTO relation_taxonomy SELECT DISTINCT R0.docid, R0.type, R0.eid1, R0.eid2, R0.entity1, R0.entity2, 0 as id, R0.label AS label
          FROM relation_taxonomy_supervise R0
        
          
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_71" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_37 {
        sql: """ 
        INSERT INTO sentences_serialized 
            SELECT DISTINCT R0.docid AS "sentences.R0.docid" , R0.sentid AS "sentences.R0.sentid" , array_to_string(R0.wordindex, '@@@@@'), array_to_string(R0.words, '@@@@@'), array_to_string(R0.poses, '@@@@@'), array_to_string(R0.ners, '@@@@@'), array_to_string(R0.lemmas, '@@@@@'), array_to_string(R0.dep_paths, '@@@@@'), array_to_string(R0.dep_parents, '@@@@@'), array_to_string(R0.font, '@@@@@'), array_to_string(R0.layout, '@@@@@')
            FROM sentences R0
        
        """
        style: "sql_extractor"
          
      }
    

      deepdive.extraction.extractors.extraction_rule_85 {
        sql: """ 
        INSERT INTO relation_taxonomy_global 
            SELECT DISTINCT R0.type AS "relation_taxonomy.R0.type" , R0.eid1 AS "relation_taxonomy.R0.eid1" , R0.eid2 AS "relation_taxonomy.R0.eid2" 
            FROM relation_taxonomy R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_75" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_47 {
        sql: """ 
        INSERT INTO taxon_per_doc 
            SELECT  R0.docid AS "entity_taxon_candidate_local.R0.docid" , ARRAY_AGG(R0.entity) AS "ARRAY_AGG_R0.entity", ARRAY_AGG(R0.type) AS "ARRAY_AGG_R0.type"
            FROM entity_taxon_candidate_local R0
        
        GROUP BY R0.docid
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_45" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_63 {
        sql: """ 
        INSERT INTO document_with_all_entities 
            SELECT  R0.docid AS "all_entity_per_doc.R0.docid" , array_to_string(R0.entity, '@@@@@'), array_to_string(R0.type, '@@@@@'), array_to_string(R0.eid, '@@@@@'), array_to_string(R0.prov, '@@@@@'), R1.sentids AS "documents_serialized.R1.sentids" , R1.wordidxs AS "documents_serialized.R1.wordidxs" , R1.words AS "documents_serialized.R1.words" , R1.poses AS "documents_serialized.R1.poses" , R1.ners AS "documents_serialized.R1.ners" , R1.lemmas AS "documents_serialized.R1.lemmas" , R1.dep_paths AS "documents_serialized.R1.dep_paths" , R1.dep_parents AS "documents_serialized.R1.dep_parents" , R1.font AS "documents_serialized.R1.font" , R1.layout AS "documents_serialized.R1.layout" 
            FROM all_entity_per_doc R0, documents_serialized R1
        WHERE R1.docid = R0.docid  
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_62" ,  "extraction_rule_39" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_90 {
        sql: """ 
        INSERT INTO entity_formation 
            SELECT  R0.docid AS "entity_formation_candidate.R0.docid" , R0.type AS "entity_formation_candidate.R0.type" , R0.eid AS "entity_formation_candidate.R0.eid" , R0.entity AS "entity_formation_candidate.R0.entity" , R0.prov AS "entity_formation_candidate.R0.prov" 
            FROM entity_formation_candidate R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_51" ,  "extraction_rule_50" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_55 {
        sql: """ 
        INSERT INTO entity_taxon_candidate 
            SELECT  R0.docid AS "entity_taxon_candidate_local.R0.docid" , R0.type AS "entity_taxon_candidate_local.R0.type" , R0.eid AS "entity_taxon_candidate_local.R0.eid" , R0.entity AS "entity_taxon_candidate_local.R0.entity" , R0.author_year AS "entity_taxon_candidate_local.R0.author_year" , R0.prov AS "entity_taxon_candidate_local.R0.prov" 
            FROM entity_taxon_candidate_local R0
        
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_45" ]
      }
    

        deepdive.extraction.extractors.extraction_rule_69 {
          input: """ SELECT * FROM relation_candidates
          """
          output_relation: "relation_formationtemporal_supervise"
          udf: ${APP_HOME}"/udf/supervise_formationtemporal.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_65" ,  "extraction_rule_67" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_71 {
          input: """ SELECT * FROM relation_candidates
          """
          output_relation: "relation_taxonomy_supervise"
          udf: ${APP_HOME}"/udf/supervise_taxonomy.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_65" ,  "extraction_rule_67" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_73 {
          input: """ SELECT * FROM relation_candidates
          """
          output_relation: "relation_formation_supervise"
          udf: ${APP_HOME}"/udf/supervise_formation.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_65" ,  "extraction_rule_67" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_57 {
          input: """ SELECT * FROM documents_serialized
          """
          output_relation: "entity_location_candidate"
          udf: ${APP_HOME}"/udf/ext_location_global.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_39" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_54 {
          input: """ SELECT * FROM document_with_taxon_entities
          """
          output_relation: "entity_taxon_candidate"
          udf: ${APP_HOME}"/udf/ext_taxon_global.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_53" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_50 {
          input: """ SELECT * FROM document_with_formation_entities
          """
          output_relation: "entity_formation_candidate"
          udf: ${APP_HOME}"/udf/ext_formation_global.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_49" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_41 {
          input: """ SELECT * FROM sentences_serialized
          """
          output_relation: "entity_formation_candidate_local"
          udf: ${APP_HOME}"/udf/ext_formation_local.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_37" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_43 {
          input: """ SELECT * FROM sentences_serialized
          """
          output_relation: "entity_temporal_candidate"
          udf: ${APP_HOME}"/udf/ext_temporal_local.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_37" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_45 {
          input: """ SELECT * FROM sentences_serialized
          """
          output_relation: "entity_taxon_candidate_local"
          udf: ${APP_HOME}"/udf/ext_taxon_local.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_37" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_65 {
          input: """ SELECT * FROM document_with_all_entities
          """
          output_relation: "relation_candidates"
          udf: ${APP_HOME}"/udf/ext_relation_samesent.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_63" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_67 {
          input: """ SELECT * FROM document_with_all_entities
          """
          output_relation: "relation_candidates"
          udf: ${APP_HOME}"/udf/ext_relation_sectionheader.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_63" ]
        }
      

        deepdive.inference.factors.relation_formationlocation_0 {
          input_query: """
          SELECT R0.id AS "relation_formationlocation.R0.id" , R1.features AS "relation_candidates.R1.features" 
          FROM relation_formationlocation R0, relation_candidates R1
        WHERE R1.docid = R0.docid  AND R1.type = 'FORMATIONLOCATION' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2  """
          function: "Imply(relation_formationlocation.R0.label)"
          weight: "?(relation_candidates.R1.features)"
        }
      

        deepdive.inference.factors.relation_formationtemporal_global_1 {
          input_query: """
          SELECT R0.id AS "relation_formationtemporal_global.R0.id" , R1.id AS "relation_formationtemporal.R1.id" , R2.features AS "relation_candidates.R2.features" 
          FROM relation_formationtemporal_global R0, relation_formationtemporal R1, relation_candidates R2
        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2  """
          function: "Imply(relation_formationtemporal.R1.label, relation_formationtemporal_global.R0.label)"
          weight: "?(relation_candidates.R2.features)"
        }
      

        deepdive.inference.factors.relation_formationtemporal_2 {
          input_query: """
          SELECT R0.id AS "relation_formationtemporal.R0.id" , R2.id AS "entity_formation.R2.id" , R3.id AS "entity_temporal.R3.id" , R1.features AS "relation_candidates.R1.features" 
          FROM relation_formationtemporal R0, relation_candidates R1, entity_formation R2, entity_temporal R3
        WHERE R1.docid = R0.docid  AND R1.type = 'FORMATIONINTERVAL' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2  AND R2.docid = R0.docid  AND R2.eid = R0.eid1  AND R2.entity = R0.entity1  AND R3.docid = R0.docid  AND R3.eid = R0.eid2  AND R3.entity = R0.entity2  """
          function: "Imply(entity_formation.R2.label, entity_temporal.R3.label, relation_formationtemporal.R0.label)"
          weight: "?(relation_candidates.R1.features)"
        }
      

        deepdive.inference.factors.entity_location_3 {
          input_query: """
          SELECT R0.id AS "entity_location.R0.id" , R0.type AS "entity_location.R0.type" 
          FROM entity_location R0, entity_location_candidate R1
        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov  """
          function: "Imply(entity_location.R0.label)"
          weight: "?(entity_location.R0.type)"
        }
      

        deepdive.inference.factors.relation_formation_global_4 {
          input_query: """
          SELECT R0.id AS "relation_formation_global.R0.id" , R1.id AS "relation_formation.R1.id" , R2.features AS "relation_candidates.R2.features" 
          FROM relation_formation_global R0, relation_formation R1, relation_candidates R2
        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2  """
          function: "Imply(relation_formation.R1.label, relation_formation_global.R0.label)"
          weight: "?(relation_candidates.R2.features)"
        }
      

        deepdive.inference.factors.relation_formationlocation_global_5 {
          input_query: """
          SELECT R0.id AS "relation_formationlocation_global.R0.id" , R1.id AS "relation_formationlocation.R1.id" , R2.features AS "relation_candidates.R2.features" 
          FROM relation_formationlocation_global R0, relation_formationlocation R1, relation_candidates R2
        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2  """
          function: "Imply(relation_formationlocation.R1.label, relation_formationlocation_global.R0.label)"
          weight: "?(relation_candidates.R2.features)"
        }
      

        deepdive.inference.factors.entity_temporal_6 {
          input_query: """
          SELECT R0.id AS "entity_temporal.R0.id" , R0.type AS "entity_temporal.R0.type" 
          FROM entity_temporal R0, entity_temporal_candidate R1
        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov  """
          function: "Imply(entity_temporal.R0.label)"
          weight: "?(entity_temporal.R0.type)"
        }
      

        deepdive.inference.factors.relation_formation_7 {
          input_query: """
          SELECT R0.id AS "relation_formation.R0.id" , R1.features AS "relation_candidates.R1.features" 
          FROM relation_formation R0, relation_candidates R1
        WHERE R1.docid = R0.docid  AND R1.type = 'FORMATION' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2  """
          function: "Imply(relation_formation.R0.label)"
          weight: "?(relation_candidates.R1.features)"
        }
      

        deepdive.inference.factors.entity_taxon_8 {
          input_query: """
          SELECT R0.id AS "entity_taxon.R0.id" , R0.type AS "entity_taxon.R0.type" 
          FROM entity_taxon R0, entity_taxon_candidate R1
        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.author_year = R0.author_year  AND R1.prov = R0.prov  """
          function: "Imply(entity_taxon.R0.label)"
          weight: "?(entity_taxon.R0.type)"
        }
      

        deepdive.inference.factors.relation_taxonomy_9 {
          input_query: """
          SELECT R0.id AS "relation_taxonomy.R0.id" , R1.features AS "relation_candidates.R1.features" 
          FROM relation_taxonomy R0, relation_candidates R1
        WHERE R1.docid = R0.docid  AND R1.type = 'TAXONOMY' AND R1.eid1 = R0.eid1  AND R1.eid2 = R0.eid2  AND R1.entity1 = R0.entity1  AND R1.entity2 = R0.entity2  """
          function: "Imply(relation_taxonomy.R0.label)"
          weight: "?(relation_candidates.R1.features)"
        }
      

        deepdive.inference.factors.relation_taxonomy_global_10 {
          input_query: """
          SELECT R0.id AS "relation_taxonomy_global.R0.id" , R1.id AS "relation_taxonomy.R1.id" , R2.features AS "relation_candidates.R2.features" 
          FROM relation_taxonomy_global R0, relation_taxonomy R1, relation_candidates R2
        WHERE R1.type = R0.type  AND R1.eid1 = R0.entity1  AND R1.eid2 = R0.entity2  AND R2.docid = R1.docid  AND R2.eid1 = R0.entity1  AND R2.eid2 = R0.entity2  AND R2.entity1 = R1.entity1  AND R2.entity2 = R1.entity2  """
          function: "Imply(relation_taxonomy.R1.label, relation_taxonomy_global.R0.label)"
          weight: "?(relation_candidates.R2.features)"
        }
      

        deepdive.inference.factors.entity_formation_11 {
          input_query: """
          SELECT R0.id AS "entity_formation.R0.id" , R0.type AS "entity_formation.R0.type" 
          FROM entity_formation R0, entity_formation_candidate R1
        WHERE R1.docid = R0.docid  AND R1.type = R0.type  AND R1.eid = R0.eid  AND R1.entity = R0.entity  AND R1.prov = R0.prov  """
          function: "Imply(entity_formation.R0.label)"
          weight: "?(entity_formation.R0.type)"
        }
      
deepdive.pipeline.run: ${PIPELINE}
deepdive.pipeline.pipelines.initdb: [extraction_rule_12, extraction_rule_0, extraction_rule_25, extraction_rule_18, extraction_rule_5, extraction_rule_14, extraction_rule_29, extraction_rule_1, extraction_rule_6, extraction_rule_4, extraction_rule_32, extraction_rule_16, extraction_rule_35, extraction_rule_24, extraction_rule_21, extraction_rule_31, extraction_rule_33, extraction_rule_27, extraction_rule_3, extraction_rule_30, extraction_rule_11, extraction_rule_7, extraction_rule_15, extraction_rule_22, extraction_rule_23, extraction_rule_10, extraction_rule_20, extraction_rule_26, extraction_rule_2, extraction_rule_34, extraction_rule_13, extraction_rule_36, extraction_rule_28, extraction_rule_17, extraction_rule_19, extraction_rule_8, extraction_rule_9]
deepdive.pipeline.pipelines.extraction: [extraction_rule_75, extraction_rule_69, extraction_rule_47, extraction_rule_90, extraction_rule_58, extraction_rule_65, extraction_rule_53, extraction_rule_54, extraction_rule_39, extraction_rule_50, extraction_rule_77, extraction_rule_43, extraction_rule_37, extraction_rule_83, extraction_rule_91, extraction_rule_76, extraction_rule_84, extraction_rule_55, extraction_rule_49, extraction_rule_92, extraction_rule_67, extraction_rule_45, extraction_rule_38, extraction_rule_71, extraction_rule_41, extraction_rule_63, extraction_rule_85, extraction_rule_74, extraction_rule_46, extraction_rule_51, extraction_rule_57, extraction_rule_62, extraction_rule_82, extraction_rule_73, extraction_rule_93]
deepdive.pipeline.pipelines.inference: [relation_formationlocation_0, relation_formationtemporal_global_1, relation_formationtemporal_2, entity_location_3, relation_formation_global_4, relation_formationlocation_global_5, entity_temporal_6, relation_formation_7, entity_taxon_8, relation_taxonomy_9, relation_taxonomy_global_10, entity_formation_11]
deepdive.pipeline.pipelines.endtoend: [extraction_rule_75, extraction_rule_69, extraction_rule_47, extraction_rule_90, extraction_rule_58, extraction_rule_65, extraction_rule_53, extraction_rule_54, extraction_rule_39, extraction_rule_50, extraction_rule_77, extraction_rule_43, extraction_rule_37, extraction_rule_83, extraction_rule_91, extraction_rule_76, extraction_rule_84, extraction_rule_55, extraction_rule_49, extraction_rule_92, extraction_rule_67, extraction_rule_45, extraction_rule_38, extraction_rule_71, extraction_rule_41, extraction_rule_63, extraction_rule_85, extraction_rule_74, extraction_rule_46, extraction_rule_51, extraction_rule_57, extraction_rule_62, extraction_rule_82, extraction_rule_73, extraction_rule_93, relation_formationlocation_0, relation_formationtemporal_global_1, relation_formationtemporal_2, entity_location_3, relation_formation_global_4, relation_formationlocation_global_5, entity_temporal_6, relation_formation_7, entity_taxon_8, relation_taxonomy_9, relation_taxonomy_global_10, entity_formation_11]
deepdive.pipeline.pipelines.cleanup: [cleanup]
